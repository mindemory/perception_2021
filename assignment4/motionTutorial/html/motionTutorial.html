
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN">
<html xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      -->
      <title>motionTutorial</title>
      <meta name="generator" content="MATLAB 7.5">
      <meta name="date" content="2007-11-07">
      <meta name="m-file" content="motionTutorial"><style>

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head>
   <body>
      <div class="content">
         <h2>Contents</h2>
         <div>
            <ul>
               <li><a href="#2">Motion in space-time and spatiotemporal linera filters</a></li>
               <li><a href="#10">Motion Energy</a></li>
               <li><a href="#13">Gradient Methods for Velocity Computation</a></li>
               <li><a href="#23">Motion in the Frequency Domain</a></li>
               <li><a href="#28">Temporal Aliasing</a></li>
            </ul>
         </div><pre class="codeinput"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="comment">%  File: motion1D.m</span>
<span class="comment">%  Author: Eero Simoncelli</span>
<span class="comment">%  Spring, 1998.  Upgraded, 6/02.</span>
<span class="comment">%</span>
<span class="comment">%  Partially based on earlier Cold Spring Harbor Tutorials written by</span>
<span class="comment">%  Eero Simoncelli and Geoff Boynton.</span>
<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>

<span class="comment">% This tutorial presents some concepts for representing and analyzing</span>
<span class="comment">% visual motion. The examples are done in a single spatial dimension, to</span>
<span class="comment">% keep things simple. We first describe an implementation of a "motion</span>
<span class="comment">% energy" model, as described by Adelson &amp; Bergen in 'Spatiotemporal Energy</span>
<span class="comment">% Models for the Perception of Motion' (JOSA-A,2:284-299). We show how</span>
<span class="comment">% linear separable filters can be added and subtracted to form space-time</span>
<span class="comment">% oriented linear filters. These oriented filters, which are selective to</span>
<span class="comment">% direction of motion, can be combined nonlinearly to produce filters that</span>
<span class="comment">% are not only motion selective, but are also insensitive to phase. Such</span>
<span class="comment">% response properties are typical of V1 complex cells.</span>

<span class="comment">% We also describe the relationship of this construction to the</span>
<span class="comment">% gradient-based algorithms widely used in Computer Vision for estimating</span>
<span class="comment">% optical flow.</span>

<span class="comment">% Finally, we'll look at these solutions in the Fourier domain.</span>

<span class="comment">% To run the tutorial, you need to have matlabPyrTools in your matlab path.</span>
<span class="comment">% The matlabPyrTools are available at:</span>

<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
</pre><h2>Motion in space-time and spatiotemporal linera filters<a name="2"></a></h2><pre class="codeinput"><span class="comment">% Motion corresponds to orientation in space-time. Consider a spot of light</span>
<span class="comment">% one pixel wide, translating to the right at one pixel per frame. We can</span>
<span class="comment">% view the sequence of signals in the X (space) and T (time) dimensions,</span>
<span class="comment">% with amplitude corresponding to intensity:</span>
stim = eye(64);
figure(1);  showIm(stim);
xlabel(<span class="string">'Position'</span>);  ylabel(<span class="string">'Time'</span>);
set(get(gca,<span class="string">'Ylabel'</span>),<span class="string">'Visible'</span>,<span class="string">'on'</span>)

<span class="comment">% The horizontial axis specifies spatial position, and vertical axis</span>
<span class="comment">% corresponds to time (up=earlier, down=later). Each pixel gives the</span>
<span class="comment">% intensity of the signal at a different spatial position and time. The</span>
<span class="comment">% motion of the spot corresponds to the fact that its position changes over</span>
<span class="comment">% time. This is just the (inverse of) the slope of the line traced out by</span>
<span class="comment">% the spot in space-time.</span>

<span class="comment">% In order to represent or estimate local velocity, one needs to make</span>
<span class="comment">% measurements of this space-time orientation.  We'll do this using a set</span>
<span class="comment">% of spatio-temporal filters.</span>
</pre><pre class="codeoutput">WARNING: You should compile the MEX version of "range2.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster.
</pre><img vspace="5" hspace="5" src="motionTutorial_01.png"> <p>First, we construct two (one-dimensional) spatial filters:</p><pre class="codeinput">sfilt = upBlur([0 0 0.107517 0.074893 -0.469550 0 <span class="keyword">...</span>
      0.469550 -0.074893 -0.107517 0 0]);
sdfilt = upBlur([0 0 0.201624 -0.424658 -0.252747 0.940351 <span class="keyword">...</span>
      -0.252747 -0.424658 0.201624 0 0]/1.8);
figure(1)
subplot(1,2,1); plot(sfilt); hold <span class="string">on</span>; plot(sdfilt,<span class="string">'r'</span>); hold <span class="string">off</span>
xlabel(<span class="string">'Space'</span>);
</pre><pre class="codeoutput">WARNING: You should compile the MEX version of "upConv.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster, and provides more boundary-handling options.

stop =

     1    22

WARNING: You should compile the MEX version of "upConv.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster, and provides more boundary-handling options.

stop =

     1    22

</pre><img vspace="5" hspace="5" src="motionTutorial_02.png"> <p>Next, create two causal temporal filters, one that contains more ripples than the other:</p><pre class="codeinput">tsz = 25;
tfilt = 2*temp_imp_resp(5,22,[0:tsz]'/tsz);
tdfilt = temp_imp_resp(2.5,22,[0:tsz]'/tsz)/2.5;
subplot(1,2,2); plot(tfilt); hold <span class="string">on</span>; plot(tdfilt,<span class="string">'r'</span>); hold <span class="string">off</span>
xlabel(<span class="string">'Time'</span>);
</pre><img vspace="5" hspace="5" src="motionTutorial_03.png"> <p>And now we create separable filters by taking the outer products of the four combinations of spatial  and temporal filters:</p><pre class="codeinput">even_slow = tfilt * sdfilt;
even_fast = tdfilt * sdfilt ;
odd_slow = tfilt * sfilt ;
odd_fast = tdfilt * sfilt ;

figure(2)
subplot(2,4,1);showIm(odd_fast,<span class="string">'auto'</span>,<span class="string">'auto'</span>,0);
subplot(2,4,2);showIm(odd_slow,<span class="string">'auto'</span>,<span class="string">'auto'</span>,0);
subplot(2,4,3);showIm(even_slow,<span class="string">'auto'</span>,<span class="string">'auto'</span>,0);
subplot(2,4,4);showIm(even_fast,<span class="string">'auto'</span>,<span class="string">'auto'</span>,0);
</pre><pre class="codeoutput">WARNING: You should compile the MEX version of "range2.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster.
WARNING: You should compile the MEX version of "range2.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster.
WARNING: You should compile the MEX version of "range2.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster.
WARNING: You should compile the MEX version of "range2.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster.
</pre><img vspace="5" hspace="5" src="motionTutorial_04.png"> <p>These separable filters can be added or subtracted in pairs to produce filters that are space-time oriented, roughly analogous
            to the receptive field properties of V1 simple cells. For example, adding the odd_fast filter to the even_slow filter results
            in a linear filter that is selective for leftward motion. We can make four such filters:
         </p><pre class="codeinput">leftward_1=odd_fast+even_slow;
leftward_2=-odd_slow+even_fast;
rightward_1=-odd_fast+even_slow;
rightward_2=odd_slow+even_fast;

subplot(2,4,5);showIm(leftward_1,<span class="string">'auto'</span>,<span class="string">'auto'</span>,0);
subplot(2,4,6);showIm(leftward_2,<span class="string">'auto'</span>,<span class="string">'auto'</span>,0);
subplot(2,4,7);showIm(rightward_1,<span class="string">'auto'</span>,<span class="string">'auto'</span>,0);
subplot(2,4,8);showIm(rightward_2,<span class="string">'auto'</span>,<span class="string">'auto'</span>,0);
</pre><pre class="codeoutput">WARNING: You should compile the MEX version of "range2.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster.
WARNING: You should compile the MEX version of "range2.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster.
WARNING: You should compile the MEX version of "range2.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster.
WARNING: You should compile the MEX version of "range2.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster.
</pre><img vspace="5" hspace="5" src="motionTutorial_05.png"> <p>To compute a filter's response to such a stimulus, we simply perform a 2-d convolution of the stimulus with the filter. For
            example:
         </p><pre class="codeinput">resp1 = conv2(stim,rightward_1,<span class="string">'same'</span>);
figure(3)
subplot(1,2,1); showIm(stim);
subplot(1,2,2); showIm(resp1);

<span class="comment">% The way to interpret the response image is to consider each column of the</span>
<span class="comment">% image as the the time-course of the response of a filter (cell) centered</span>
<span class="comment">% at that location. The filter responds when the impulse passes by. For</span>
<span class="comment">% example, if we consider the response of a filter centered on the center</span>
<span class="comment">% column of the response image:</span>
column=round(size(stim,2)/2); <span class="comment">%center column</span>
line([column,column],[1,size(stim,2)],<span class="string">'Color'</span>,<span class="string">'r'</span>);
</pre><pre class="codeoutput">WARNING: You should compile the MEX version of "range2.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster.
WARNING: You should compile the MEX version of "range2.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster.
</pre><img vspace="5" hspace="5" src="motionTutorial_06.png"> <p>Now look at the time course of this response:</p><pre class="codeinput">figure(4); clf
showIm(resp1(:,column)); ylabel(<span class="string">'Response'</span>); xlabel(<span class="string">'Time'</span>)
</pre><pre class="codeoutput">WARNING: You should compile the MEX version of "range2.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster.
</pre><img vspace="5" hspace="5" src="motionTutorial_07.png"> <p>Similarly, consider the response of the rightward_2 filter:</p><pre class="codeinput">resp2 = conv2(stim,rightward_2,<span class="string">'same'</span>);
subplot(1,2,2); showIm(resp2);
column=round(size(stim,2)/2); <span class="comment">%center column</span>
line([column,column],[1,size(stim,2)],<span class="string">'Color'</span>,<span class="string">'r'</span>);

figure(4);
showIm(resp1(:,column)+j*resp2(:,column));

<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
</pre><pre class="codeoutput">WARNING: You should compile the MEX version of "range2.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster.
WARNING: You should compile the MEX version of "range2.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster.
WARNING: You should compile the MEX version of "range2.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster.
</pre><img vspace="5" hspace="5" src="motionTutorial_08.png"> <h2>Motion Energy<a name="10"></a></h2><pre class="codeinput"><span class="comment">% Unlike the linear filter responses shown above, V1 complex cell responses</span>
<span class="comment">% are "phase-insensitive": they respond to drifting gratings with a</span>
<span class="comment">% more-or-less constant level of activity. Adelson/Bergen modeled this</span>
<span class="comment">% using "spatiotemporal energy": the sum of squared responses of filters</span>
<span class="comment">% with different phases. For example, we can compute rightward and</span>
<span class="comment">% leftwared energy, by adding together the squared responses:</span>

Eright = conv2(stim,rightward_1,<span class="string">'valid'</span>).^2+conv2(stim,rightward_2,<span class="string">'valid'</span>).^2;
Eleft = conv2(stim,leftward_1,<span class="string">'valid'</span>).^2+conv2(stim,leftward_2,<span class="string">'valid'</span>).^2;
subplot(1,2,2); rg=showIm(Eright,<span class="string">'auto'</span>,<span class="string">'auto'</span>,<span class="string">'Rightward energy'</span>)
subplot(1,2,1); showIm(Eleft,rg,<span class="string">'auto'</span>,<span class="string">'Leftward energy'</span>)
</pre><pre class="codeoutput">WARNING: You should compile the MEX version of "range2.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster.

rg =

         0    0.0279


ans =

         0    0.0279

</pre><img vspace="5" hspace="5" src="motionTutorial_09.png"> <p>To see the phase-insensitivity, we make a new stimulus that contains a leftward- and rightward-moving sinusoidal grating:</p><pre class="codeinput">stim = [mkSine(64,8,pi/4); mkSine(64,8,-pi/4)];
figure(3)
subplot(1,3,1); showIm(stim); title(<span class="string">'stimulus'</span>)

resp1 = conv2(stim,rightward_1,<span class="string">'same'</span>);
subplot(1,3,2); showIm(resp1);  title(<span class="string">'rightward filter response'</span>)

resp2 = conv2(stim,rightward_2,<span class="string">'same'</span>);
Eright = resp1.^2+resp2.^2;
subplot(1,3,3); showIm(Eright); title(<span class="string">'rightward energy'</span>)
</pre><pre class="codeoutput">WARNING: You should compile the MEX version of "range2.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster.
WARNING: You should compile the MEX version of "range2.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster.
WARNING: You should compile the MEX version of "range2.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster.
</pre><img vspace="5" hspace="5" src="motionTutorial_10.png"> <p>Now try this on the Adelson/Bergen stimulus of figure 15:</p><pre class="codeinput">dims = [100,80];
t_profile = dims(2)/2 + (dims(2)/8)*cos(3*pi*[0:dims(1)-1]'/dims(1));
[lutX,lutY] = rcosFn(2);
stim = pointOp((ones(dims(1),1)*[1:dims(2)])-(t_profile*ones(1,dims(2))), <span class="keyword">...</span>
    lutY, lutX(1), lutX(2)-lutX(1),0);

figure(4); clf
subplot(1,3,1); showIm(stim); title(<span class="string">'stimulus'</span>)
Eright = conv2(stim,rightward_1,<span class="string">'valid'</span>).^2+conv2(stim,rightward_2,<span class="string">'valid'</span>).^2;
Eleft = conv2(stim,leftward_1,<span class="string">'valid'</span>).^2+conv2(stim,leftward_2,<span class="string">'valid'</span>).^2;
Estatic = conv2(stim,odd_slow,<span class="string">'valid'</span>).^2+conv2(stim,odd_fast,<span class="string">'valid'</span>).^2+<span class="keyword">...</span>
     conv2(stim,even_slow,<span class="string">'valid'</span>).^2+conv2(stim,even_fast,<span class="string">'valid'</span>).^2;
subplot(1,3,2); showIm(Eright); title(<span class="string">'rightward energy'</span>);
subplot(1,3,3); showIm(Eleft); title(<span class="string">'leftward energy'</span>);

<span class="comment">% The energy responses are smooth and are selective for their</span>
<span class="comment">% corresponding motions.</span>

<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
</pre><pre class="codeoutput">WARNING: You should compile the MEX version of "pointOp.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster.
WARNING: You should compile the MEX version of "range2.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster.
WARNING: You should compile the MEX version of "range2.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster.
WARNING: You should compile the MEX version of "range2.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster.
</pre><img vspace="5" hspace="5" src="motionTutorial_11.png"> <h2>Gradient Methods for Velocity Computation<a name="13"></a></h2><pre class="codeinput"><span class="comment">% As described above, motion is orientation in space-time. Computationally,</span>
<span class="comment">% we'd like to describe a method for estimating this orientation. This</span>
<span class="comment">% requires that we specify the relationship between the local velocity and</span>
<span class="comment">% the image intensity. The standard method of doing this is to assume that</span>
<span class="comment">% the image is translating (but not changing in any other way) over time:</span>
<span class="comment">%</span>
<span class="comment">%   I(x, t + Dt) = I(x - v.Dt, t)</span>
<span class="comment">%</span>
<span class="comment">% If we assume the time interval Dt  is small, we can expand both sides of</span>
<span class="comment">% the equation in a first-order Taylor series:</span>
<span class="comment">%</span>
<span class="comment">%  I(x, t) + Dt * dI/dt = I(x, t) - v * Dt * dI/dx</span>
<span class="comment">%</span>
<span class="comment">% After eliminating common terms, we get:</span>
<span class="comment">%</span>
<span class="comment">%  dI/dt  + v dI/dx = 0</span>
<span class="comment">%</span>
<span class="comment">% This is known as the "differential brightness constancy constraint".</span>

<span class="comment">% Derivatives are only properly defined for continuous signals - in order</span>
<span class="comment">% to compute derivatives of sampled signals, one needs to interpolate them.</span>
<span class="comment">% For this tutorial, we'll do our interpolating with a circularly-symmetric</span>
<span class="comment">% Gaussian, which has the nice property that it is separable.</span>
X=[-5:5];  sig=2;
gFilt = exp(- (X.^2)/(2*sig^2));
dFilt = X .* gFilt;
dxFilt = gFilt' * dFilt;   <span class="comment">% separable combinations</span>
dtFilt = dFilt' * gFilt;
clf; showIm(dxFilt + i*dtFilt,<span class="string">'auto'</span>,<span class="string">'auto'</span>,<span class="keyword">...</span>
       <span class="string">'Space-time weighting functions of derivative filters'</span>);
xlabel(<span class="string">'X derivative                 T derivative'</span>);
</pre><pre class="codeoutput">WARNING: You should compile the MEX version of "range2.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster.
WARNING: You should compile the MEX version of "range2.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster.
</pre><img vspace="5" hspace="5" src="motionTutorial_12.png"> <p>Notice that because these filters are separable, and are NOT selective for a particular direction of motion. But derivatives
            in two dimensions have a beautiful rotation-invariance property: the derivative in an arbitrary directions is just a linear
            combination of the derivatives along the two axes. For example:
         </p><pre class="codeinput">angle = pi/6;
angleFilt = cos(angle) * dxFilt + sin(angle) * dtFilt;
figure; showIm(angleFilt);
</pre><pre class="codeoutput">WARNING: You should compile the MEX version of "range2.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster.
</pre><img vspace="5" hspace="5" src="motionTutorial_13.png"> <p>Because of this property, one way to think about computing velocity is to find the angle at which we get a maximal filter
            response. We first compute the filter responses in the center of the xt image:
         </p><pre class="codeinput">sz=64;
xtImpulse = eye(sz);
res = cconv2(xtImpulse, dxFilt);
xFiltResp = res(sz/2-1,sz/2);
res = cconv2(xtImpulse, dtFilt);
tFiltResp = res(sz/2-1,sz/2);
</pre><p>...and use the rotation-invariance property to compute the responses at a bunch of angles:</p><pre class="codeinput">angles = (pi) * [-16:16]/16;
responses = cos(angles) * xFiltResp + sin(angles) * tFiltResp;
clf; plot(angles, responses);
xlabel(<span class="string">'filter preferred angle (radians)'</span>);
ylabel(<span class="string">'filter response'</span>);
</pre><img vspace="5" hspace="5" src="motionTutorial_14.png"> <p>The peak response is at -45 degrees, which corresponds to a rightward velocity of 1 pixel/frame. Instead of searching for
            the filter that gives the largest response, we can compute an estimate of velocity at each point in space and time using the
            gradient constraint:
         </p><pre class="codeinput">dxImpulse = corrDn(xtImpulse,dxFilt,<span class="string">'dont-compute'</span>);
dtImpulse = corrDn(xtImpulse,dtFilt,<span class="string">'dont-compute'</span>);

<span class="comment">% We can compute an estimate of velocity at each point in space and time using</span>
<span class="comment">% the gradient constraint.</span>
vImpulse = - dtImpulse ./ dxImpulse;

<span class="comment">% You should have gotten a "divide by zero" warning, resulting in a</span>
<span class="comment">% velocity field with lots of NaN (non-a-number) values, because the</span>
<span class="comment">% dxImpulse image has lots of zeros. We can do something a bit arbitrary to</span>
<span class="comment">% fix this (we'll fix it more properly in a moment):</span>
dxImpulse = dxImpulse + (abs(dxImpulse)&lt;1e-3);
vImpulse = - dtImpulse ./ dxImpulse;
clf; showIm(vImpulse,<span class="string">'auto'</span>,<span class="string">'auto'</span>,<span class="string">'Speed estimates over space-time'</span>);
</pre><pre class="codeoutput">WARNING: You should compile the MEX version of "corrDn.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster, and provides more boundary-handling options.
Warning: Using REFLECT1 edge-handling (use MEX code for other options).
WARNING: You should compile the MEX version of "corrDn.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster, and provides more boundary-handling options.
Warning: Using REFLECT1 edge-handling (use MEX code for other options).
WARNING: You should compile the MEX version of "range2.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster.
</pre><img vspace="5" hspace="5" src="motionTutorial_15.png"> <p>What you see is an x-t image of VELOCITY ESTIMATES. The intensity at each point is proportional to estimated speed. The white
            pixels have a value of one, the correct speed. But, there is an oblique line of zeroes in between the two lines of ones, and
            the remainder of the image is filled with zeros. The problem is that the spatial derivative dx-impulse is zero at some locations
            and we cannot compute the velocity at those points.
         </p><pre class="codeinput"><span class="comment">% To "fix" the strip of zeroes between the lines of ones, we can combine</span>
<span class="comment">% the derivative measurements over a local neighborhood (by blurring the</span>
<span class="comment">% squared filter outputs). This comes from combining the derivative</span>
<span class="comment">% constraint over small neighborhoods, in a squared-error fashion:</span>
<span class="comment">%</span>
<span class="comment">%     E(v) = sum ( Ix*v + It )^2.</span>
<span class="comment">%</span>
<span class="comment">% The minimal solution for v is:</span>
<span class="comment">%</span>
<span class="comment">%     v = -sum(Ix*It) / sum(Ix*Ix)</span>

<span class="comment">% The local summation can be implemented using a convolution with a lowpass</span>
<span class="comment">% filter.  We'll choose a 5-tap binomial coefficient filter:</span>
blurFilt = namedFilter(<span class="string">'binom5'</span>)*namedFilter(<span class="string">'binom5'</span>)';

dxImpulse = corrDn(xtImpulse,dxFilt,<span class="string">'dont-compute'</span>);
dtImpulse = corrDn(xtImpulse,dtFilt,<span class="string">'dont-compute'</span>);
vBlurImpulse = - (corrDn(dtImpulse*dxImpulse,blurFilt,<span class="string">'dont-compute'</span>)) ./ <span class="keyword">...</span>
                   (1e-4 + (corrDn(dxImpulse*dxImpulse,blurFilt,<span class="string">'dont-compute'</span>)));
vBlurImpulse(1:6,1:6)
clf; showIm(vBlurImpulse,<span class="string">'auto'</span>,<span class="string">'auto'</span>,<span class="string">'Speed estimates over space-time'</span>);

<span class="comment">% The velocity estimate is now correct (v=1) in the vicinity of the</span>
<span class="comment">% moving impulse. You still get zero far from the diagonal (also near</span>
<span class="comment">% the edges, because we are unable to compute derivatives there).</span>
<span class="comment">% This is because these locations are so far away from the moving</span>
<span class="comment">% impulse that the neighborhood over which their velocities are</span>
<span class="comment">% computed do not contain any motion information. This problem occurs</span>
<span class="comment">% in an even more serious way in 2D.</span>
</pre><pre class="codeoutput">WARNING: You should compile the MEX version of "corrDn.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster, and provides more boundary-handling options.
Warning: Using REFLECT1 edge-handling (use MEX code for other options).
WARNING: You should compile the MEX version of "corrDn.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster, and provides more boundary-handling options.
Warning: Using REFLECT1 edge-handling (use MEX code for other options).
WARNING: You should compile the MEX version of "corrDn.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster, and provides more boundary-handling options.
Warning: Using REFLECT1 edge-handling (use MEX code for other options).
WARNING: You should compile the MEX version of "corrDn.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster, and provides more boundary-handling options.
Warning: Using REFLECT1 edge-handling (use MEX code for other options).

ans =

    1.3430    1.6258    2.7509  -55.2018   -1.5453   -0.5347
    1.6912    1.9648    2.8504    8.6877   -3.7890   -1.0296
    2.1372    2.3129    2.7342    3.7090    8.2912   -6.9647
    2.2790    2.3349    2.4412    2.6036    2.9026    3.6844
    2.3137    2.2706    2.1948    2.1031    2.0095    1.9440
    2.5564    2.3582    2.0906    1.8480    1.6451    1.4909

WARNING: You should compile the MEX version of "range2.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster.
</pre><img vspace="5" hspace="5" src="motionTutorial_16.png"> <p>How is this related to the Adelson-Bergen calculation? First we note that:</p><pre>  Ix*It = 1/4 * [ (Ix + It)^2 - (Ix - It)^2 ]</pre><p>and thus the solution for v given above may be written:</p><pre>  v = -[ sum(Ix + It)^2 - sum(Ix - It)^2 ] / 4*sum(Ix)^2</pre><p>Now the numerator is a difference of sum-of-squared linear measurements. Because of the properties of multi-dimensional derivatives,
            each of these measurements corresponds to the convolution with a single derivative filter, where the derivative is taken in
            a direction of +/- 45 degrees. The squaring and blurring is a form of local energy calculation. Under suitable conditions,
            this can be made formally  equivalent to the sum of squares of even and odd filters given in Adelson and Bergen. So the numerator
            corresponds to rightward minus leftward energy. The denominator is the "static" energy.
         </p>
         <p>The only other issue is the choice of filters. The gradient algorithm described above  relies on two filters that are the
            temporal and spatial derivatives of a common "prefilter". The Adelson-bergen filters approximately satisfy this constraint
            (and one can design filters satisfying the constraint that are quite similar to the Adelson-Bergen filters). In this case,
            the prefilter is a separable bandpass filter.
         </p>
         <p>Now we'll compute velocity on a one-dimensional image with more interesting content.  We'll make a 1D fractal noise signal:</p><pre class="codeinput">fract = mkFract([1 32],2);
clf; plot(fract);
xlabel(<span class="string">'Position'</span>)
ylabel(<span class="string">'Intensity (arbitrary units)'</span>)
</pre><img vspace="5" hspace="5" src="motionTutorial_17.png"> <p>And now we make it move leftward at a rate of one pixel per time-step:</p><pre class="codeinput">xtFract  = zeros(16,size(fract,2));
<span class="keyword">for</span> row = 1:size(xtFract,1)
	xtFract(row,:) = [fract(1,(33-row):32), fract(1,1:(32-row))];
<span class="keyword">end</span>
showIm(xtFract)
</pre><pre class="codeoutput">WARNING: You should compile the MEX version of "range2.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster.

ans =

   -2.2409    1.9572

</pre><img vspace="5" hspace="5" src="motionTutorial_18.png"> <p>And compute the velocity</p><pre class="codeinput">vBlurFract = compute1dFlow(xtFract);
clf; showIm(vBlurFract,<span class="string">'auto'</span>,<span class="string">'auto'</span>,<span class="string">'Speed estimates over space-time'</span>);

<span class="comment">% Now the entire space-time image of speed estimates contains values close</span>
<span class="comment">% to 1 because the entire pattern is moving 1 pixel per frame.</span>

<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
</pre><pre class="codeoutput">WARNING: You should compile the MEX version of "corrDn.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster, and provides more boundary-handling options.
Warning: Using REFLECT1 edge-handling (use MEX code for other options).
WARNING: You should compile the MEX version of "corrDn.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster, and provides more boundary-handling options.
Warning: Using REFLECT1 edge-handling (use MEX code for other options).
WARNING: You should compile the MEX version of "corrDn.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster, and provides more boundary-handling options.
Warning: Using REFLECT1 edge-handling (use MEX code for other options).
WARNING: You should compile the MEX version of "corrDn.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster, and provides more boundary-handling options.
Warning: Using REFLECT1 edge-handling (use MEX code for other options).
WARNING: You should compile the MEX version of "range2.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster.
</pre><img vspace="5" hspace="5" src="motionTutorial_19.png"> <h2>Motion in the Frequency Domain<a name="23"></a></h2>
         <p>A connection between the gradient and spatio-temporal energy mechanisms</p><pre class="codeinput"><span class="comment">% A translating one-dimensional pattern has a fourier spectrum lying on a</span>
<span class="comment">% line through the origin. The slope of the line corresponds to the pattern</span>
<span class="comment">% velocity. Take a look  at the Fourier amplitude of the moving fractal</span>
<span class="comment">% pattern:</span>

fractMag = fftshift(abs(fft2(xtFract,16,16)));
clf; showIm(fractMag,[0 100],<span class="string">'auto'</span>,<span class="string">'Spatiotemporal Fourier amplitude'</span>);

<span class="comment">% The Fourier magnitude image is plotted over a range of [-pi, pi] in both</span>
<span class="comment">% the wx (spatial frequency) and wt (temporal frequency) directions. Most</span>
<span class="comment">% of the energy in this stimulus lies along an oblique line in wx-wt.</span>
<span class="comment">% [But why doesn't it lie EXACTLY on a line?]</span>
</pre><img vspace="5" hspace="5" src="motionTutorial_20.png"> <p>Remember that convolution corresponds to multiplication in the frequency domain. Therefore, the Fourier Transform of the derivative
            images (dxFract and dtFract) corresponds to the product of the DFT's of the filter and fract. Let's look at the Fourier magnitude
            of the filters:
         </p><pre class="codeinput">dtMag = fftshift(abs(fft2(dtFilt,32,32)));
dxMag = fftshift(abs(fft2(dxFilt,32,32)));
clf; showIm(dxMag + i*dtMag,<span class="string">'auto'</span>,<span class="string">'auto'</span>,<span class="keyword">...</span>
       <span class="string">'Spatiotemporal freq responses of t- and x-deriv filters'</span>);
</pre><pre class="codeoutput">WARNING: You should compile the MEX version of "range2.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster.
WARNING: You should compile the MEX version of "range2.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster.
</pre><img vspace="5" hspace="5" src="motionTutorial_21.png"> <p>We can write the temporal derivative as a sum of two other spatio-temporal filters oriented at +/- 45 degrees (that is, filters
            that are most sensitive to either rightward or leftward motion):
         </p><pre class="codeinput">drFilt = (dxFilt+dtFilt)/2;
dlFilt = (dxFilt-dtFilt)/2;
clf; showIm(dlFilt + i*drFilt,<span class="string">'auto'</span>,<span class="string">'auto'</span>,<span class="keyword">...</span>
       <span class="string">'Space-time weighting functions of right- and left-selective filters'</span>);
</pre><pre class="codeoutput">WARNING: You should compile the MEX version of "range2.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster.
WARNING: You should compile the MEX version of "range2.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster.
</pre><img vspace="5" hspace="5" src="motionTutorial_22.png"> <p>Now look at the FTs of these two direction selective filters. They are rightward and leftward spatiotemporal energy filters.</p><pre class="codeinput">rMag = fftshift(abs(fft2(drFilt,32,32)));
lMag = fftshift(abs(fft2(dlFilt,32,32)));
clf; showIm(rMag + i*lMag,<span class="string">'auto'</span>,<span class="string">'auto'</span>,<span class="keyword">...</span>
       <span class="string">'Spatiotemporal freq responses of right and left-selective filters'</span>);
</pre><pre class="codeoutput">WARNING: You should compile the MEX version of "range2.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster.
WARNING: You should compile the MEX version of "range2.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster.
</pre><img vspace="5" hspace="5" src="motionTutorial_23.png"> <p>Given this relationship between right-/left-selective filters and the x-/t-derivative filters, we can now rewrite the velocity
            calculation to look like an Adelson-Bergen spatio-temporal energy calculation:
         </p>
         <p>velocity = (R - L)/S</p>
         <p>where R and L are rightward and leftward "energy", and S is static energy (computed with the X derivative).</p><pre class="codeinput">dlFract = corrDn(xtFract,dlFilt,<span class="string">'dont-compute'</span>);
drFract = corrDn(xtFract,drFilt,<span class="string">'dont-compute'</span>);
dxFract = corrDn(xtFract,dxFilt,<span class="string">'dont-compute'</span>);

lEnergy = corrDn(dlFract.*dlFract, blurFilt,<span class="string">'dont-compute'</span>);
rEnergy = corrDn(drFract.*drFract, blurFilt,<span class="string">'dont-compute'</span>);
sEnergy = corrDn(dxFract.*dxFract, blurFilt,<span class="string">'dont-compute'</span>);
sEnergy = sEnergy + 1e-4;  <span class="comment">%% avoid divide-by-zero</span>

vBlurSteFract = (lEnergy - rEnergy) ./ sEnergy;
figure;
showIm(vBlurSteFract, <span class="string">'auto'</span>,<span class="string">'auto'</span>,<span class="keyword">...</span>
       <span class="string">'Speed, computed with opponent energy mechanism'</span>);

<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
</pre><pre class="codeoutput">WARNING: You should compile the MEX version of "corrDn.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster, and provides more boundary-handling options.
Warning: Using REFLECT1 edge-handling (use MEX code for other options).
WARNING: You should compile the MEX version of "corrDn.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster, and provides more boundary-handling options.
Warning: Using REFLECT1 edge-handling (use MEX code for other options).
WARNING: You should compile the MEX version of "corrDn.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster, and provides more boundary-handling options.
Warning: Using REFLECT1 edge-handling (use MEX code for other options).
WARNING: You should compile the MEX version of "corrDn.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster, and provides more boundary-handling options.
Warning: Using REFLECT1 edge-handling (use MEX code for other options).
WARNING: You should compile the MEX version of "corrDn.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster, and provides more boundary-handling options.
Warning: Using REFLECT1 edge-handling (use MEX code for other options).
WARNING: You should compile the MEX version of "corrDn.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster, and provides more boundary-handling options.
Warning: Using REFLECT1 edge-handling (use MEX code for other options).
WARNING: You should compile the MEX version of "range2.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster.
</pre><img vspace="5" hspace="5" src="motionTutorial_24.png"> <h2>Temporal Aliasing<a name="28"></a></h2><pre class="codeinput"><span class="comment">% The patterns above were moving only one pixel per frame. Now consider a</span>
<span class="comment">% pattern moving three pixels per frame:</span>
speed = 3;
fract2 = mkFract([1 64],2);
xtFract2  = zeros(16,size(fract2,2));
<span class="keyword">for</span> row = 1:size(xtFract2,1)
	xtFract2(row,:) = [fract2(1,(65-row*speed):64), fract2(1,1:(64-row*speed))];
<span class="keyword">end</span>
clf; showIm(xtFract2,<span class="string">'auto'</span>,<span class="string">'auto'</span>,<span class="string">'Intensity over space-time'</span>);
</pre><pre class="codeoutput">WARNING: You should compile the MEX version of "range2.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster.
</pre><img vspace="5" hspace="5" src="motionTutorial_25.png"> <p>Now let's try to estimate the velocity of this stimulus:</p><pre class="codeinput">vBlurFract2 = compute1dFlow(xtFract2);
clf; showIm(vBlurFract2,<span class="string">'auto'</span>,<span class="string">'auto'</span>,<span class="string">'Speed estimates over space-time'</span>);
</pre><pre class="codeoutput">WARNING: You should compile the MEX version of "corrDn.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster, and provides more boundary-handling options.
Warning: Using REFLECT1 edge-handling (use MEX code for other options).
WARNING: You should compile the MEX version of "corrDn.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster, and provides more boundary-handling options.
Warning: Using REFLECT1 edge-handling (use MEX code for other options).
WARNING: You should compile the MEX version of "corrDn.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster, and provides more boundary-handling options.
Warning: Using REFLECT1 edge-handling (use MEX code for other options).
WARNING: You should compile the MEX version of "corrDn.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster, and provides more boundary-handling options.
Warning: Using REFLECT1 edge-handling (use MEX code for other options).
WARNING: You should compile the MEX version of "range2.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster.
</pre><img vspace="5" hspace="5" src="motionTutorial_26.png"> <p>Look at a histogram of the estimated velocities:</p><pre class="codeinput">clf; hist(vBlurFract2(:),30);
</pre><img vspace="5" hspace="5" src="motionTutorial_27.png"> <p>The speed estimates have quite a lot of variability.  This is because the filters are too small for an image displacement
            of 2 pixels, so the algorithm is beginning to fail.  To see this another way, look at the Fourier transform of the signal:
         </p><pre class="codeinput">fract2Mag = fftshift(abs(fft2(xtFract2,32,32)));
clf; showIm(fract2Mag,[0,100],<span class="string">'auto'</span>,<span class="string">'Spatiotemporal Fourier amplitude'</span>);

<span class="comment">% You should be able to see aliased copies of the spectrum, parallel to the</span>
<span class="comment">% central "stripe".  Why does this happen?  How does it affect the derivative</span>
<span class="comment">% filters (look back at dxMag and dtMag)?</span>
</pre><img vspace="5" hspace="5" src="motionTutorial_28.png"> <p>One way to get around the temporal aliasing problem is to use derivative filters of lower spatial frequency response. These
            will not "see" the aliased copies, and thus will be able to get a better velocity estimate. Alternatively, we can blur and
            subsample the images spatially, thus reducing the motion displacement per frame.
         </p><pre class="codeinput">xtFract2Blur = corrDn(xtFract2,namedFilter(<span class="string">'gauss5'</span>)',<span class="string">'circular'</span>,[1 2]);
clf; showIm(xtFract2Blur,<span class="string">'auto'</span>,<span class="string">'auto'</span>,<span class="string">'Coarse scale intensity over space-time'</span>);
</pre><pre class="codeoutput">WARNING: You should compile the MEX version of "corrDn.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster, and provides more boundary-handling options.
Warning: Using REFLECT1 edge-handling (use MEX code for other options).
WARNING: You should compile the MEX version of "range2.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster.
</pre><img vspace="5" hspace="5" src="motionTutorial_29.png"> <p>Note that the aliasing in the power spectrum will now have a much smaller effect on the filters because most of the energy
            is now back on the main diagonal:
         </p><pre class="codeinput">xtFract2BlurMag = fftshift(abs(fft2(xtFract2Blur,32,32)));
clf; showIm(xtFract2BlurMag,[0,100],<span class="string">'auto'</span>,<span class="string">'Spatiotemporal Fourier amplitude'</span>);
</pre><img vspace="5" hspace="5" src="motionTutorial_30.png"> <p>Now we can compute motion on this blurred and subsampled image. Remember that the resulting velocities must now be multiplied
            by 2 to get them in units of pixels/frame relative to the sampling of the original images.
         </p><pre class="codeinput">v2BlurFract2 = 2 * compute1dFlow(xtFract2Blur);
clf; showIm(v2BlurFract2,<span class="string">'auto'</span>,<span class="string">'auto'</span>,<span class="string">'Speed estimates'</span>);
</pre><pre class="codeoutput">WARNING: You should compile the MEX version of "corrDn.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster, and provides more boundary-handling options.
Warning: Using REFLECT1 edge-handling (use MEX code for other options).
WARNING: You should compile the MEX version of "corrDn.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster, and provides more boundary-handling options.
Warning: Using REFLECT1 edge-handling (use MEX code for other options).
WARNING: You should compile the MEX version of "corrDn.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster, and provides more boundary-handling options.
Warning: Using REFLECT1 edge-handling (use MEX code for other options).
WARNING: You should compile the MEX version of "corrDn.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster, and provides more boundary-handling options.
Warning: Using REFLECT1 edge-handling (use MEX code for other options).
WARNING: You should compile the MEX version of "range2.c",
         found in the MEX subdirectory of matlabPyrTools, and put it in your matlab path.  It is MUCH faster.
</pre><img vspace="5" hspace="5" src="motionTutorial_31.png"> <p>The  histogram now shows most values near the correct speed (red line):</p><pre class="codeinput">figure;
hist(v2BlurFract2(:),30);
hold <span class="string">on</span>; line(speed*[1 1], [0 20], <span class="string">'Color'</span>, <span class="string">'red'</span>); hold <span class="string">off</span>

<span class="comment">% We will stop here. But note that the current velocity field is computed</span>
<span class="comment">% at reduced resolution, and we may want higher resolution velocity fields.</span>
<span class="comment">% In particular, for real images, the motion is often NOT uniform</span>
<span class="comment">% translation. Thus we want to use the smallest filters possible to compute</span>
<span class="comment">% the most LOCAL velocity possible.</span>

<span class="comment">% One solution is to use a "coarse-to-fine" procedure which is a standard</span>
<span class="comment">% trick in image processing and computer vision. Get an initial estimate at</span>
<span class="comment">% the coarse scale using big filters (or equivalently, using blurred and</span>
<span class="comment">% subsampled images). Then refine that estimate at successively finer</span>
<span class="comment">% scales. After computing the initial coarse scale estimate of the</span>
<span class="comment">% velocity, "undo" motion by aligning the images according to the</span>
<span class="comment">% coarse-scale estimate. To undo the motion, translate or "warp" each frame</span>
<span class="comment">% (each scan line of the X-T diagram) back toward the center frame</span>
<span class="comment">% according to our current motion. Then the finer scale filters are used to</span>
<span class="comment">% compute a correction to the coarse-scale flow field.</span>
</pre><img vspace="5" hspace="5" src="motionTutorial_32.png"> <p class="footer"><br>
            Published with MATLAB&reg; 7.5<br></p>
      </div>
      <!--
##### SOURCE BEGIN #####
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  File: motion1D.m%  Author: Eero Simoncelli%  Spring, 1998.  Upgraded, 6/02.%%  Partially based on earlier Cold Spring Harbor Tutorials written by%  Eero Simoncelli and Geoff Boynton.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% This tutorial presents some concepts for representing and analyzing% visual motion. The examples are done in a single spatial dimension, to% keep things simple. We first describe an implementation of a "motion% energy" model, as described by Adelson & Bergen in 'Spatiotemporal Energy% Models for the Perception of Motion' (JOSA-A,2:284-299). We show how% linear separable filters can be added and subtracted to form space-time% oriented linear filters. These oriented filters, which are selective to% direction of motion, can be combined nonlinearly to produce filters that% are not only motion selective, but are also insensitive to phase. Such% response properties are typical of V1 complex cells.% We also describe the relationship of this construction to the% gradient-based algorithms widely used in Computer Vision for estimating% optical flow.% Finally, we'll look at these solutions in the Fourier domain.% To run the tutorial, you need to have matlabPyrTools in your matlab path.% The matlabPyrTools are available at:%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Motion in space-time and spatiotemporal linera filters% Motion corresponds to orientation in space-time. Consider a spot of light% one pixel wide, translating to the right at one pixel per frame. We can% view the sequence of signals in the X (space) and T (time) dimensions,% with amplitude corresponding to intensity:stim = eye(64);figure(1);  showIm(stim);xlabel('Position');  ylabel('Time');set(get(gca,'Ylabel'),'Visible','on')% The horizontial axis specifies spatial position, and vertical axis% corresponds to time (up=earlier, down=later). Each pixel gives the% intensity of the signal at a different spatial position and time. The% motion of the spot corresponds to the fact that its position changes over% time. This is just the (inverse of) the slope of the line traced out by% the spot in space-time.% In order to represent or estimate local velocity, one needs to make% measurements of this space-time orientation.  We'll do this using a set% of spatio-temporal filters.%%% First, we construct two (one-dimensional) spatial filters:sfilt = upBlur([0 0 0.107517 0.074893 -0.469550 0 ...      0.469550 -0.074893 -0.107517 0 0]);sdfilt = upBlur([0 0 0.201624 -0.424658 -0.252747 0.940351 ...      -0.252747 -0.424658 0.201624 0 0]/1.8);figure(1)subplot(1,2,1); plot(sfilt); hold on; plot(sdfilt,'r'); hold offxlabel('Space'); %%% Next, create two causal temporal filters, one that contains more ripples% than the other:tsz = 25;tfilt = 2*temp_imp_resp(5,22,[0:tsz]'/tsz);tdfilt = temp_imp_resp(2.5,22,[0:tsz]'/tsz)/2.5;subplot(1,2,2); plot(tfilt); hold on; plot(tdfilt,'r'); hold offxlabel('Time');%%% And now we create separable filters by taking the outer products of the% four combinations of spatial  and temporal filters:even_slow = tfilt * sdfilt;even_fast = tdfilt * sdfilt ;odd_slow = tfilt * sfilt ;odd_fast = tdfilt * sfilt ;figure(2)subplot(2,4,1);showIm(odd_fast,'auto','auto',0);subplot(2,4,2);showIm(odd_slow,'auto','auto',0);subplot(2,4,3);showIm(even_slow,'auto','auto',0);subplot(2,4,4);showIm(even_fast,'auto','auto',0);%%% These separable filters can be added or subtracted in pairs to produce% filters that are space-time oriented, roughly analogous to the receptive% field properties of V1 simple cells. For example, adding the odd_fast% filter to the even_slow filter results in a linear filter that is% selective for leftward motion. We can make four such filters: leftward_1=odd_fast+even_slow; leftward_2=-odd_slow+even_fast;rightward_1=-odd_fast+even_slow;rightward_2=odd_slow+even_fast;subplot(2,4,5);showIm(leftward_1,'auto','auto',0);subplot(2,4,6);showIm(leftward_2,'auto','auto',0);subplot(2,4,7);showIm(rightward_1,'auto','auto',0);subplot(2,4,8);showIm(rightward_2,'auto','auto',0);%%% To compute a filter's response to such a stimulus, we simply perform a% 2-d convolution of the stimulus with the filter. For example:resp1 = conv2(stim,rightward_1,'same');figure(3)subplot(1,2,1); showIm(stim);subplot(1,2,2); showIm(resp1);% The way to interpret the response image is to consider each column of the% image as the the time-course of the response of a filter (cell) centered% at that location. The filter responds when the impulse passes by. For% example, if we consider the response of a filter centered on the center% column of the response image:column=round(size(stim,2)/2); %center columnline([column,column],[1,size(stim,2)],'Color','r');%% % Now look at the time course of this response:figure(4); clfshowIm(resp1(:,column)); ylabel('Response'); xlabel('Time')%% % Similarly, consider the response of the rightward_2 filter:resp2 = conv2(stim,rightward_2,'same');subplot(1,2,2); showIm(resp2);column=round(size(stim,2)/2); %center columnline([column,column],[1,size(stim,2)],'Color','r');figure(4);showIm(resp1(:,column)+j*resp2(:,column));%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Motion Energy% Unlike the linear filter responses shown above, V1 complex cell responses% are "phase-insensitive": they respond to drifting gratings with a% more-or-less constant level of activity. Adelson/Bergen modeled this% using "spatiotemporal energy": the sum of squared responses of filters% with different phases. For example, we can compute rightward and% leftwared energy, by adding together the squared responses:Eright = conv2(stim,rightward_1,'valid').^2+conv2(stim,rightward_2,'valid').^2;Eleft = conv2(stim,leftward_1,'valid').^2+conv2(stim,leftward_2,'valid').^2;subplot(1,2,2); rg=showIm(Eright,'auto','auto','Rightward energy')subplot(1,2,1); showIm(Eleft,rg,'auto','Leftward energy')%%% To see the phase-insensitivity, we make a new stimulus that contains a% leftward- and rightward-moving sinusoidal grating:stim = [mkSine(64,8,pi/4); mkSine(64,8,-pi/4)];figure(3)subplot(1,3,1); showIm(stim); title('stimulus') resp1 = conv2(stim,rightward_1,'same');subplot(1,3,2); showIm(resp1);  title('rightward filter response')resp2 = conv2(stim,rightward_2,'same');Eright = resp1.^2+resp2.^2;subplot(1,3,3); showIm(Eright); title('rightward energy')%% % Now try this on the Adelson/Bergen stimulus of figure 15:dims = [100,80];t_profile = dims(2)/2 + (dims(2)/8)*cos(3*pi*[0:dims(1)-1]'/dims(1));[lutX,lutY] = rcosFn(2);stim = pointOp((ones(dims(1),1)*[1:dims(2)])-(t_profile*ones(1,dims(2))), ...    lutY, lutX(1), lutX(2)-lutX(1),0);figure(4); clfsubplot(1,3,1); showIm(stim); title('stimulus')Eright = conv2(stim,rightward_1,'valid').^2+conv2(stim,rightward_2,'valid').^2;Eleft = conv2(stim,leftward_1,'valid').^2+conv2(stim,leftward_2,'valid').^2;Estatic = conv2(stim,odd_slow,'valid').^2+conv2(stim,odd_fast,'valid').^2+...     conv2(stim,even_slow,'valid').^2+conv2(stim,even_fast,'valid').^2;subplot(1,3,2); showIm(Eright); title('rightward energy');subplot(1,3,3); showIm(Eleft); title('leftward energy');% The energy responses are smooth and are selective for their% corresponding motions.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Gradient Methods for Velocity Computation% As described above, motion is orientation in space-time. Computationally,% we'd like to describe a method for estimating this orientation. This% requires that we specify the relationship between the local velocity and% the image intensity. The standard method of doing this is to assume that% the image is translating (but not changing in any other way) over time:%%   I(x, t + Dt) = I(x - v.Dt, t) %% If we assume the time interval Dt  is small, we can expand both sides of% the equation in a first-order Taylor series:%%  I(x, t) + Dt * dI/dt = I(x, t) - v * Dt * dI/dx%% After eliminating common terms, we get:%%  dI/dt  + v dI/dx = 0%% This is known as the "differential brightness constancy constraint".% Derivatives are only properly defined for continuous signals - in order% to compute derivatives of sampled signals, one needs to interpolate them.% For this tutorial, we'll do our interpolating with a circularly-symmetric% Gaussian, which has the nice property that it is separable.X=[-5:5];  sig=2;gFilt = exp(- (X.^2)/(2*sig^2));dFilt = X .* gFilt;dxFilt = gFilt' * dFilt;   % separable combinations dtFilt = dFilt' * gFilt;clf; showIm(dxFilt + i*dtFilt,'auto','auto',...       'Space-time weighting functions of derivative filters');xlabel('X derivative                 T derivative');%%% Notice that because these filters are separable, and are NOT selective% for a particular direction of motion. But derivatives in two dimensions% have a beautiful rotation-invariance property: the derivative in an% arbitrary directions is just a linear combination of the derivatives% along the two axes. For example:angle = pi/6;angleFilt = cos(angle) * dxFilt + sin(angle) * dtFilt;figure; showIm(angleFilt);%%% Because of this property, one way to think about computing velocity is to% find the angle at which we get a maximal filter response. We first% compute the filter responses in the center of the xt image:sz=64;xtImpulse = eye(sz);res = cconv2(xtImpulse, dxFilt);xFiltResp = res(sz/2-1,sz/2);res = cconv2(xtImpulse, dtFilt);tFiltResp = res(sz/2-1,sz/2);%%% ...and use the rotation-invariance property to compute the responses at a% bunch of angles:angles = (pi) * [-16:16]/16;responses = cos(angles) * xFiltResp + sin(angles) * tFiltResp;clf; plot(angles, responses);xlabel('filter preferred angle (radians)');ylabel('filter response');%%% The peak response is at -45 degrees, which corresponds to a rightward% velocity of 1 pixel/frame. Instead of searching for the filter that gives% the largest response, we can compute an estimate of velocity at each% point in space and time using the gradient constraint:dxImpulse = corrDn(xtImpulse,dxFilt,'dont-compute');dtImpulse = corrDn(xtImpulse,dtFilt,'dont-compute');% We can compute an estimate of velocity at each point in space and time using% the gradient constraint.vImpulse = - dtImpulse ./ dxImpulse;% You should have gotten a "divide by zero" warning, resulting in a% velocity field with lots of NaN (non-a-number) values, because the% dxImpulse image has lots of zeros. We can do something a bit arbitrary to% fix this (we'll fix it more properly in a moment):dxImpulse = dxImpulse + (abs(dxImpulse)<1e-3);vImpulse = - dtImpulse ./ dxImpulse;clf; showIm(vImpulse,'auto','auto','Speed estimates over space-time');%%% What you see is an x-t image of VELOCITY ESTIMATES. The intensity at% each point is proportional to estimated speed. The white pixels have a% value of one, the correct speed. But, there is an oblique line of zeroes% in between the two lines of ones, and the remainder of the image is% filled with zeros. The problem is that the spatial derivative dx-impulse% is zero at some locations and we cannot compute the velocity at those% points.% To "fix" the strip of zeroes between the lines of ones, we can combine% the derivative measurements over a local neighborhood (by blurring the% squared filter outputs). This comes from combining the derivative% constraint over small neighborhoods, in a squared-error fashion:%%     E(v) = sum ( Ix*v + It )^2.%% The minimal solution for v is:%%     v = -sum(Ix*It) / sum(Ix*Ix)% The local summation can be implemented using a convolution with a lowpass% filter.  We'll choose a 5-tap binomial coefficient filter:blurFilt = namedFilter('binom5')*namedFilter('binom5')';dxImpulse = corrDn(xtImpulse,dxFilt,'dont-compute');dtImpulse = corrDn(xtImpulse,dtFilt,'dont-compute');vBlurImpulse = - (corrDn(dtImpulse*dxImpulse,blurFilt,'dont-compute')) ./ ...                   (1e-4 + (corrDn(dxImpulse*dxImpulse,blurFilt,'dont-compute')));vBlurImpulse(1:6,1:6)clf; showIm(vBlurImpulse,'auto','auto','Speed estimates over space-time');% The velocity estimate is now correct (v=1) in the vicinity of the% moving impulse. You still get zero far from the diagonal (also near% the edges, because we are unable to compute derivatives there).% This is because these locations are so far away from the moving% impulse that the neighborhood over which their velocities are% computed do not contain any motion information. This problem occurs% in an even more serious way in 2D.%%% How is this related to the Adelson-Bergen calculation? First we note% that:%%    Ix*It = 1/4 * [ (Ix + It)^2 - (Ix - It)^2 ]%% and thus the solution for v given above may be written:%%    v = -[ sum(Ix + It)^2 - sum(Ix - It)^2 ] / 4*sum(Ix)^2%% Now the numerator is a difference of sum-of-squared linear measurements.% Because of the properties of multi-dimensional derivatives, each of these% measurements corresponds to the convolution with a single derivative% filter, where the derivative is taken in a direction of +/- 45 degrees.% The squaring and blurring is a form of local energy calculation. Under% suitable conditions, this can be made formally  equivalent to the sum of% squares of even and odd filters given in Adelson and Bergen. So the% numerator corresponds to rightward minus leftward energy. The denominator% is the "static" energy.  %% The only other issue is the choice of filters. The gradient algorithm% described above  relies on two filters that are the temporal and spatial% derivatives of a common "prefilter". The Adelson-bergen filters% approximately satisfy this constraint (and one can design filters% satisfying the constraint that are quite similar to the Adelson-Bergen% filters). In this case, the prefilter is a separable bandpass filter.%%% Now we'll compute velocity on a one-dimensional image with more% interesting content.  We'll make a 1D fractal noise signal:fract = mkFract([1 32],2);clf; plot(fract);xlabel('Position')ylabel('Intensity (arbitrary units)')%%% And now we make it move leftward at a rate of one pixel per time-step:xtFract  = zeros(16,size(fract,2));for row = 1:size(xtFract,1)	xtFract(row,:) = [fract(1,(33-row):32), fract(1,1:(32-row))];endshowIm(xtFract)%%% And compute the velocityvBlurFract = compute1dFlow(xtFract);clf; showIm(vBlurFract,'auto','auto','Speed estimates over space-time');% Now the entire space-time image of speed estimates contains values close% to 1 because the entire pattern is moving 1 pixel per frame.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Motion in the Frequency Domain% A connection between the gradient and spatio-temporal energy mechanisms% A translating one-dimensional pattern has a fourier spectrum lying on a% line through the origin. The slope of the line corresponds to the pattern% velocity. Take a look  at the Fourier amplitude of the moving fractal% pattern:fractMag = fftshift(abs(fft2(xtFract,16,16)));clf; showIm(fractMag,[0 100],'auto','Spatiotemporal Fourier amplitude');% The Fourier magnitude image is plotted over a range of [-pi, pi] in both% the wx (spatial frequency) and wt (temporal frequency) directions. Most% of the energy in this stimulus lies along an oblique line in wx-wt.  % [But why doesn't it lie EXACTLY on a line?]%%% Remember that convolution corresponds to multiplication in the frequency% domain. Therefore, the Fourier Transform of the derivative images% (dxFract and dtFract) corresponds to the product of the DFT's of the% filter and fract. Let's look at the Fourier magnitude of the filters:dtMag = fftshift(abs(fft2(dtFilt,32,32)));dxMag = fftshift(abs(fft2(dxFilt,32,32)));clf; showIm(dxMag + i*dtMag,'auto','auto',...       'Spatiotemporal freq responses of t- and x-deriv filters');%%% We can write the temporal derivative as a sum of two other% spatio-temporal filters oriented at +/- 45 degrees (that is, filters that% are most sensitive to either rightward or leftward motion):drFilt = (dxFilt+dtFilt)/2;dlFilt = (dxFilt-dtFilt)/2;clf; showIm(dlFilt + i*drFilt,'auto','auto',...       'Space-time weighting functions of right- and left-selective filters');%%% Now look at the FTs of these two direction selective filters. They are% rightward and leftward spatiotemporal energy filters.rMag = fftshift(abs(fft2(drFilt,32,32)));lMag = fftshift(abs(fft2(dlFilt,32,32)));clf; showIm(rMag + i*lMag,'auto','auto',...       'Spatiotemporal freq responses of right and left-selective filters');%%% Given this relationship between right-/left-selective filters and the% x-/t-derivative filters, we can now rewrite the velocity calculation to % look like an Adelson-Bergen spatio-temporal energy calculation: %% velocity = (R - L)/S%% where R and L are rightward and leftward "energy", and S is% static energy (computed with the X derivative).dlFract = corrDn(xtFract,dlFilt,'dont-compute');drFract = corrDn(xtFract,drFilt,'dont-compute');dxFract = corrDn(xtFract,dxFilt,'dont-compute');lEnergy = corrDn(dlFract.*dlFract, blurFilt,'dont-compute');rEnergy = corrDn(drFract.*drFract, blurFilt,'dont-compute');sEnergy = corrDn(dxFract.*dxFract, blurFilt,'dont-compute');sEnergy = sEnergy + 1e-4;  %% avoid divide-by-zerovBlurSteFract = (lEnergy - rEnergy) ./ sEnergy;figure;showIm(vBlurSteFract, 'auto','auto',...       'Speed, computed with opponent energy mechanism');%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Temporal Aliasing% The patterns above were moving only one pixel per frame. Now consider a% pattern moving three pixels per frame:speed = 3;fract2 = mkFract([1 64],2);xtFract2  = zeros(16,size(fract2,2));for row = 1:size(xtFract2,1)	xtFract2(row,:) = [fract2(1,(65-row*speed):64), fract2(1,1:(64-row*speed))];endclf; showIm(xtFract2,'auto','auto','Intensity over space-time');%%% Now let's try to estimate the velocity of this stimulus:vBlurFract2 = compute1dFlow(xtFract2);clf; showIm(vBlurFract2,'auto','auto','Speed estimates over space-time');%%% Look at a histogram of the estimated velocities:clf; hist(vBlurFract2(:),30);%%% The speed estimates have quite a lot of variability.  This is% because the filters are too small for an image displacement of 2% pixels, so the algorithm is beginning to fail.  To see this another% way, look at the Fourier transform of the signal:fract2Mag = fftshift(abs(fft2(xtFract2,32,32)));clf; showIm(fract2Mag,[0,100],'auto','Spatiotemporal Fourier amplitude');% You should be able to see aliased copies of the spectrum, parallel to the% central "stripe".  Why does this happen?  How does it affect the derivative% filters (look back at dxMag and dtMag)?%% % One way to get around the temporal aliasing problem is to use derivative% filters of lower spatial frequency response. These will not "see" the% aliased copies, and thus will be able to get a better velocity estimate.% Alternatively, we can blur and subsample the images spatially, thus% reducing the motion displacement per frame.xtFract2Blur = corrDn(xtFract2,namedFilter('gauss5')','circular',[1 2]);clf; showIm(xtFract2Blur,'auto','auto','Coarse scale intensity over space-time');%%% Note that the aliasing in the power spectrum will now have a much smaller% effect on the filters because most of the energy is now back on the main% diagonal:xtFract2BlurMag = fftshift(abs(fft2(xtFract2Blur,32,32)));clf; showIm(xtFract2BlurMag,[0,100],'auto','Spatiotemporal Fourier amplitude');%%% Now we can compute motion on this blurred and subsampled image. Remember% that the resulting velocities must now be multiplied by 2 to get them in% units of pixels/frame relative to the sampling of the original images.v2BlurFract2 = 2 * compute1dFlow(xtFract2Blur);clf; showIm(v2BlurFract2,'auto','auto','Speed estimates');%%% The  histogram now shows most values near the correct speed (red line):figure;  hist(v2BlurFract2(:),30);hold on; line(speed*[1 1], [0 20], 'Color', 'red'); hold off % We will stop here. But note that the current velocity field is computed% at reduced resolution, and we may want higher resolution velocity fields.% In particular, for real images, the motion is often NOT uniform% translation. Thus we want to use the smallest filters possible to compute% the most LOCAL velocity possible.% One solution is to use a "coarse-to-fine" procedure which is a standard% trick in image processing and computer vision. Get an initial estimate at% the coarse scale using big filters (or equivalently, using blurred and% subsampled images). Then refine that estimate at successively finer% scales. After computing the initial coarse scale estimate of the% velocity, "undo" motion by aligning the images according to the% coarse-scale estimate. To undo the motion, translate or "warp" each frame% (each scan line of the X-T diagram) back toward the center frame% according to our current motion. Then the finer scale filters are used to% compute a correction to the coarse-scale flow field.
##### SOURCE END #####
-->
   </body>
</html>