
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Q3</title><meta name="generator" content="MATLAB 9.11"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2021-12-07"><meta name="DC.source" content="Q3.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">a)</a></li><li><a href="#4">b)</a></li><li><a href="#6">c)</a></li><li><a href="#8">d)</a></li></ul></div><pre class="codeinput">clear; close <span class="string">all</span>; clc;
</pre><h2 id="2">a)</h2><p>Temporal and spatial filters are computed. These filters are then convolved to compute oddFast, oddSlow, evenFast, evenSlow. The orientation of the spatial filters determines the orientation of the convolved outputs. The y-t slices are plotted for horizontal spatial filters and x-t slices are plotted for vertical spatial filters.</p><pre class="codeinput">tic
deltaX = 1/120; <span class="comment">% spatial sampling rate</span>
x_x = -2:deltaX:2; <span class="comment">% spatial array along x axis</span>
x_y = -2:deltaX:2; <span class="comment">% spatial array along y axis</span>
deltaT = 1; <span class="comment">% ms</span>
duration = 1000; <span class="comment">% ms</span>

t = 0:deltaT:duration-deltaT; <span class="comment">% time-array</span>

x = zeros(length(x_x), length(x_y), length(t));
x(241, 241, 1) = 1; <span class="comment">% Impulse at center of screen at time = 0</span>

tau = 25; <span class="comment">% ms</span>

[f1, f2] = time_filters(x, t, deltaT, tau); <span class="comment">% computes temporal filters</span>

sig = 0.1; <span class="comment">% standard deviation of the Gaussian (in deg)</span>
sf = 4; <span class="comment">% spatial frequency of the sinusoid (in cyc/deg)</span>

[evenFilt, oddFilt] = gabor_filter(x_x, sig, sf); <span class="comment">% computes spatial filters</span>

[oddFastlr, oddSlowlr, evenFastlr, evenSlowlr] = <span class="keyword">...</span>
    conv_filts(f1, f2, oddFilt, evenFilt); <span class="comment">% convolution of temporal and horizontal spatial filters</span>

figure();
plot_func(oddFastlr, oddSlowlr, evenFastlr, evenSlowlr, <span class="string">'Odd Fast lr'</span>, <span class="string">'Odd Slow lr'</span>, <span class="keyword">...</span>
    <span class="string">'Even Fast lr'</span>, <span class="string">'Even Slow lr'</span>, <span class="string">'lr'</span>)

[oddFastud, oddSlowud, evenFastud, evenSlowud] = <span class="keyword">...</span>
    conv_filts(f1, f2, oddFilt', evenFilt'); <span class="comment">% convolution of temporal and vertical spatial filters</span>
figure();
plot_func(oddFastud, oddSlowud, evenFastud, evenSlowud, <span class="string">'Odd Fast ud'</span>, <span class="string">'Odd Slow ud'</span>, <span class="keyword">...</span>
    <span class="string">'Even Fast ud'</span>, <span class="string">'Even Slow ud'</span>, <span class="string">'ud'</span>)
</pre><img vspace="5" hspace="5" src="Q3_01.png" alt=""> <img vspace="5" hspace="5" src="Q3_02.png" alt=""> <h2 id="4">b)</h2><p>The metrics computed in (a) are then used to compute Even1, Odd1, Even2, Odd2, Energy1, and Energy2 using motion_energy function, where 1 refers to left or up and 2 refers to right or down determined by the orientation of the spatial filters. As expected, the resulting sums obtained appear to curve in time.</p><pre class="codeinput">[leftEven, leftOdd, rightEven, rightOdd, leftEnergy, rightEnergy] = <span class="keyword">...</span>
    motion_energy(oddFastlr, oddSlowlr, evenFastlr, evenSlowlr);

[upEven, upOdd, downEven, downOdd, upEnergy, downEnergy] = <span class="keyword">...</span>
    motion_energy(oddFastud, oddSlowud, evenFastud, evenSlowud);

figure();
plot_func(leftEven, leftOdd, rightEven, rightOdd, <span class="string">'Left Even'</span>, <span class="string">'Left Odd'</span>, <span class="keyword">...</span>
    <span class="string">'Right Even'</span>, <span class="string">'Right Odd'</span>, <span class="string">'lr'</span>)

figure();
plot_func(upEven, upOdd, downEven, downOdd, <span class="string">'Up Even'</span>, <span class="string">'Up Odd'</span>, <span class="keyword">...</span>
     <span class="string">'Down Even'</span>, <span class="string">'Down Odd'</span>, <span class="string">'ud'</span>)
</pre><img vspace="5" hspace="5" src="Q3_03.png" alt=""> <img vspace="5" hspace="5" src="Q3_04.png" alt=""> <h2 id="6">c)</h2><p>The energies computed in (b) are plotted here.</p><pre class="codeinput">figure();
plot_func(leftEnergy, rightEnergy, upEnergy, downEnergy, <span class="string">'Left Energy'</span>, <span class="keyword">...</span>
    <span class="string">'Right Energy'</span>, <span class="string">'Up Energy'</span>, <span class="string">'Down Energy'</span>, <span class="string">'energy'</span>)
</pre><img vspace="5" hspace="5" src="Q3_05.png" alt=""> <h2 id="8">d)</h2><p>The neuron_responses runs the entire experiment by computing the responses of leftward, rightward, upward, downward oriented neurons for a given series of gratings over time. The gratings are designed using get_grating function that creates a sinusoidal grating in space with the spatial frequency of 4 cyc/deg. Since the spatial scale of the space varies from -2 deg to 2 deg in steps of 1/120 degree. Hence, 4 degrees correspond to 481 pixels. Therefore, the spatial frequency of the sinusoid is 4 cyc/ 481 pixels. Therefore, the time-period of the sinusoid becomes 481/4 ~ 30 pixels/cyc. The sinusoidal grating also moves in time with a frequency of 8Hz = 8 cycles/sec. 1 sec = 1000 ms = 1000 frames. Therefore, in each frame, the sinusoid moves by 1000/8 = 125 frames/cycle. Hence the phase of the sinusoid will change at each time-step by 2*pi/125 in the preferred direction. The sinusoid is then used as an input to compute time_filters which are convolved with the spatial filters to produce neuronal responses and energies.</p><pre class="codeinput">close <span class="string">all</span>; <span class="comment">%clearvars -except oddFilt evenFilt deltaX x_x x_y ;</span>

contrast = 100; <span class="comment">% contrast of the stimulus</span>
phase = 0; <span class="comment">% initial phase of the stimulus</span>
sf = 30; <span class="comment">% cycles/pixel</span>

oris = [<span class="string">"lr"</span>, <span class="string">"ud"</span>]; <span class="comment">% for left-right, and up-down</span>
phase_shifts = [2*pi/125, -2*pi/125]; <span class="comment">% cycles/frame, positive is left or down, negative is right or up</span>

<span class="keyword">for</span> ori = oris
    <span class="keyword">for</span> phase_shift = phase_shifts
        [leftEven, leftOdd, rightEven, rightOdd, leftEnergy, rightEnergy, <span class="keyword">...</span>
            upEven, upOdd, downEven, downOdd, upEnergy, downEnergy] = <span class="keyword">...</span>
            neuron_responses(x_x, x_y, t, deltaT, tau, contrast, phase, <span class="keyword">...</span>
            phase_shift, sf, ori, oddFilt, evenFilt);

        figure();
        <span class="keyword">if</span> ori == <span class="string">"lr"</span>
            <span class="keyword">if</span> phase_shift &gt; 0
                title_st = <span class="string">'leftward stimulus'</span>;
            <span class="keyword">else</span>
                title_st = <span class="string">'rightward stimulus'</span>;
            <span class="keyword">end</span>
        <span class="keyword">else</span>
            <span class="keyword">if</span> phase_shift &gt; 0
                title_st = <span class="string">'upward stimulus'</span>;
            <span class="keyword">else</span>
                title_st = <span class="string">'downward stimulus'</span>;
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        plot_energy(t, leftEnergy, leftEven, leftOdd, rightEnergy, rightEven, <span class="keyword">...</span>
            rightOdd, upEnergy, upEven, upOdd, downEnergy, downEven, downOdd, title_st)
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="Q3_06.png" alt=""> <img vspace="5" hspace="5" src="Q3_07.png" alt=""> <img vspace="5" hspace="5" src="Q3_08.png" alt=""> <img vspace="5" hspace="5" src="Q3_09.png" alt=""> <p>As can be seen, the neurons respond highest when the grating is moving in their preferred direction.</p><pre class="codeinput">toc
</pre><pre class="codeoutput">Elapsed time is 338.928858 seconds.
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2021b</a><br></p></div><!--
##### SOURCE BEGIN #####
clear; close all; clc;

%% a)
% Temporal and spatial filters are computed. These filters are then
% convolved to compute oddFast, oddSlow, evenFast, evenSlow. The
% orientation of the spatial filters determines the orientation of the
% convolved outputs. The y-t slices are plotted for horizontal spatial
% filters and x-t slices are plotted for vertical spatial filters.
%%
tic
deltaX = 1/120; % spatial sampling rate
x_x = -2:deltaX:2; % spatial array along x axis
x_y = -2:deltaX:2; % spatial array along y axis
deltaT = 1; % ms
duration = 1000; % ms

t = 0:deltaT:duration-deltaT; % time-array

x = zeros(length(x_x), length(x_y), length(t));
x(241, 241, 1) = 1; % Impulse at center of screen at time = 0

tau = 25; % ms

[f1, f2] = time_filters(x, t, deltaT, tau); % computes temporal filters

sig = 0.1; % standard deviation of the Gaussian (in deg)
sf = 4; % spatial frequency of the sinusoid (in cyc/deg)

[evenFilt, oddFilt] = gabor_filter(x_x, sig, sf); % computes spatial filters

[oddFastlr, oddSlowlr, evenFastlr, evenSlowlr] = ...
    conv_filts(f1, f2, oddFilt, evenFilt); % convolution of temporal and horizontal spatial filters

figure();
plot_func(oddFastlr, oddSlowlr, evenFastlr, evenSlowlr, 'Odd Fast lr', 'Odd Slow lr', ...
    'Even Fast lr', 'Even Slow lr', 'lr')

[oddFastud, oddSlowud, evenFastud, evenSlowud] = ...
    conv_filts(f1, f2, oddFilt', evenFilt'); % convolution of temporal and vertical spatial filters
figure();
plot_func(oddFastud, oddSlowud, evenFastud, evenSlowud, 'Odd Fast ud', 'Odd Slow ud', ...
    'Even Fast ud', 'Even Slow ud', 'ud')

%% b)
% The metrics computed in (a) are then used to compute Even1, Odd1, Even2,
% Odd2, Energy1, and Energy2 using motion_energy function, where 1 refers
% to left or up and 2 refers to right or down determined by the orientation
% of the spatial filters. As expected, the resulting sums obtained appear
% to curve in time.
%%
[leftEven, leftOdd, rightEven, rightOdd, leftEnergy, rightEnergy] = ...
    motion_energy(oddFastlr, oddSlowlr, evenFastlr, evenSlowlr);

[upEven, upOdd, downEven, downOdd, upEnergy, downEnergy] = ...
    motion_energy(oddFastud, oddSlowud, evenFastud, evenSlowud);

figure();
plot_func(leftEven, leftOdd, rightEven, rightOdd, 'Left Even', 'Left Odd', ...
    'Right Even', 'Right Odd', 'lr')

figure();
plot_func(upEven, upOdd, downEven, downOdd, 'Up Even', 'Up Odd', ...
     'Down Even', 'Down Odd', 'ud')

%% c)
% The energies computed in (b) are plotted here.
%%
figure();
plot_func(leftEnergy, rightEnergy, upEnergy, downEnergy, 'Left Energy', ...
    'Right Energy', 'Up Energy', 'Down Energy', 'energy')

%% d)
% The neuron_responses runs the entire experiment by computing the
% responses of leftward, rightward, upward, downward oriented neurons for a
% given series of gratings over time. The gratings are designed using
% get_grating function that creates a sinusoidal grating in space with the
% spatial frequency of 4 cyc/deg. Since the spatial scale of the space
% varies from -2 deg to 2 deg in steps of 1/120 degree. Hence, 4 degrees
% correspond to 481 pixels. Therefore, the spatial frequency of the
% sinusoid is 4 cyc/ 481 pixels. Therefore, the time-period of the sinusoid
% becomes 481/4 ~ 30 pixels/cyc. The sinusoidal grating also moves in time
% with a frequency of 8Hz = 8 cycles/sec. 1 sec = 1000 ms = 1000 frames.
% Therefore, in each frame, the sinusoid moves by 1000/8 = 125
% frames/cycle. Hence the phase of the sinusoid will change at each
% time-step by 2*pi/125 in the preferred direction. The sinusoid is then
% used as an input to compute time_filters which are convolved with the
% spatial filters to produce neuronal responses and energies.
%%
close all; %clearvars -except oddFilt evenFilt deltaX x_x x_y ;

contrast = 100; % contrast of the stimulus 
phase = 0; % initial phase of the stimulus
sf = 30; % cycles/pixel
                              
oris = ["lr", "ud"]; % for left-right, and up-down
phase_shifts = [2*pi/125, -2*pi/125]; % cycles/frame, positive is left or down, negative is right or up

for ori = oris
    for phase_shift = phase_shifts
        [leftEven, leftOdd, rightEven, rightOdd, leftEnergy, rightEnergy, ...
            upEven, upOdd, downEven, downOdd, upEnergy, downEnergy] = ...
            neuron_responses(x_x, x_y, t, deltaT, tau, contrast, phase, ...
            phase_shift, sf, ori, oddFilt, evenFilt);

        figure();
        if ori == "lr"
            if phase_shift > 0
                title_st = 'leftward stimulus';
            else
                title_st = 'rightward stimulus';
            end
        else
            if phase_shift > 0
                title_st = 'upward stimulus';
            else
                title_st = 'downward stimulus';
            end
        end
        plot_energy(t, leftEnergy, leftEven, leftOdd, rightEnergy, rightEven, ...
            rightOdd, upEnergy, upEven, upOdd, downEnergy, downEven, downOdd, title_st)
    end
end

%%
% As can be seen, the neurons respond highest when the grating is moving in
% their preferred direction.
toc


##### SOURCE END #####
--></body></html>