
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>color_assignment</title><meta name="generator" content="MATLAB 9.9"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2021-09-20"><meta name="DC.source" content="color_assignment.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">Q1</a></li><li><a href="#3">a)</a></li><li><a href="#4">b)</a></li><li><a href="#5">c)</a></li><li><a href="#6">d)</a></li><li><a href="#7">e)</a></li><li><a href="#8">Q2</a></li><li><a href="#9">a)</a></li><li><a href="#10">b)</a></li><li><a href="#11">Q3</a></li><li><a href="#12">a)</a></li><li><a href="#13">b)</a></li><li><a href="#15">i) Brute-force method</a></li><li><a href="#16">ii) Matrix-multiplication method</a></li><li><a href="#39">c)</a></li><li><a href="#40">Q4</a></li><li><a href="#46">Q5</a></li><li><a href="#47">a)</a></li><li><a href="#57">b)</a></li><li><a href="#59">c)</a></li></ul></div><pre class="codeinput">clear; clc; close <span class="string">all</span>;

<span class="comment">% Loading all the datasets</span>
load <span class="string">surfaces</span>;
load <span class="string">illuminants</span>;
load <span class="string">cones</span>;
load <span class="string">phosphors</span>;
</pre><h2 id="2">Q1</h2><p>First a linear vector is created using linspace to list a range of wavelengths between 400 and 700 nm to map the visual spectrum. A standard size of 31 spacings is used which ensures a 10 nm step size.</p><pre class="codeinput">spectrum = linspace(400, 700, 31);
</pre><h2 id="3">a)</h2><p>The SPD of illuminant A is given by cie_a which is 1 * 31 and the 18th macbeth surface reflectance is stored in the 18th row of macbeth matrix which has a shape of 1 * 31. Therefore, value-by-value multiplication of macbeth 18th row and cie_a is performed to compute the spectral signal reaching the eye. To ensure that the resulting spectral signal is a column vector, both the macbeth 18th row and the cia_a are transposed before computing the product</p><pre class="codeinput">spectral_signal_18_ciea = macbeth(18, :)' .* cie_a';
figure;
plot(spectrum,spectral_signal_18_ciea,<span class="string">'r'</span>, <span class="string">'LineWidth'</span>, 2);
xlabel(<span class="string">'Wavelength (nm)'</span>);
ylabel(<span class="string">'Reflected Energy'</span>);
title(<span class="string">'Reflected energy off 18th surface illuminated by illuminant A'</span>)
</pre><img vspace="5" hspace="5" src="color_assignment_01.png" alt=""> <h2 id="4">b)</h2><p>Similar to (a), the 18th macbeth surface vector is multiplied by the SPD of the fluorescent light to compute the spectral signal reaching the eye</p><pre class="codeinput">spectral_signal_18_fluroescent = macbeth(18, :)' .* flourescent';
figure;
plot(spectrum,spectral_signal_18_fluroescent,<span class="string">'g'</span>, <span class="string">'LineWidth'</span>, 2);
xlabel(<span class="string">'Wavelength (nm)'</span>);
ylabel(<span class="string">'Reflected Energy'</span>);
title(<span class="string">'Reflected energy off 18th surface illuminated by fluorescent illuminant'</span>)
</pre><img vspace="5" hspace="5" src="color_assignment_02.png" alt=""> <h2 id="5">c)</h2><p>The cone responses are the product of the matrix comprised of cone responsitivities as a function of wavelength and the spectral signal present in the incident light on the retina computed in (a) for illuminant A. The cones matrix is 3 * 31 and spectral_signal is 31 * 1 resulting in the coneResponse vector shaped 3 * 1 with values corresponding to the responses by [L M S] cones.</p><pre class="codeinput">coneResponse_18th_ciea = cones * spectral_signal_18_ciea;
disp(<span class="string">'The cone responses for illuminant A reflecting off 18th Macbeth surface are:'</span>)
disp(coneResponse_18th_ciea);
</pre><pre class="codeoutput">The cone responses for illuminant A reflecting off 18th Macbeth surface are:
   65.2373
   53.5643
   61.9800

</pre><h2 id="6">d)</h2><p>Similar to what is done in (c), the cones matrix here is multiplied by the spectral signal for the fluorescent light from (b) and the result is a 3 * 1 coneResponse vector for the fluorescent light</p><pre class="codeinput">coneResponse_18th_fluorescent = cones * spectral_signal_18_fluroescent;
disp(<span class="string">'The cone responses for fluroescnet light reflecting off 18th Macbeth surface are:'</span>)
disp(coneResponse_18th_fluorescent);
</pre><pre class="codeoutput">The cone responses for fluroescnet light reflecting off 18th Macbeth surface are:
   66.1124
   68.4875
  182.9654

</pre><h2 id="7">e)</h2><p>The fluorescent light will appear more blueish as the cone response of S cone is higher in case of fluorescent light compared to that for the illuminant A. S cone responds to shorter wavelengths which are interpreted as blueish by the brain.</p><h2 id="8">Q2</h2><h2 id="9">a)</h2><p>This is a color matching experiment where illuminant A acts as the test light and the monitor intensities are the knob settings of the three primaries. First the spectral signal reaching the eye when illuminant A is shined on the 1st Macbeth surface is computed in a similar way as in Q1 a, b. Next the coneResponse is computed as the matrix product of the cones and the spectralSignal similar as in Q1 c, d. Then a matrix is computed to convert the signals from phosphors to the signals from cones as a product of cones and phosphors. Since both cones and phosphors are 3 * 31, phosphors is transposed. The result is a 3 * 3 matrix. Given the linear independence of the three primaries i.e. phosphors and the responsivities of the three cones, the resultant phosphors_to_cones matrix is invertible and the inverse of this matrix gives cones_to_phosphors, a 3 * 3 matrix, that can be used to convert the signals from cones to the corresponding light intensities from the monitor. The monitorSignals can then be computed as the product of cones_to_phosphors and coneResponse</p><pre class="codeinput">spectral_signal_1_ciea = macbeth(1, :)' .* cie_a';
coneResponse_1st_ciea = cones * spectral_signal_1_ciea;
phosphors_to_cones = cones * phosphors';
cones_to_phosphors = inv(phosphors_to_cones);
monitorSignals = cones_to_phosphors * coneResponse_1st_ciea;
disp(<span class="string">'The monitor intensities to match the color of the 1st Macbeth surface when illuminated by illuminant A are:'</span>)
disp(monitorSignals)
</pre><pre class="codeoutput">The monitor intensities to match the color of the 1st Macbeth surface when illuminated by illuminant A are:
   1.0e+03 *

    1.7947
    1.9383
    0.4740

</pre><h2 id="10">b)</h2><p>Since all the intensities are greater than 0 and assuming that there is no maximum intensity limit for the light produced by the monitor, this color can be displayed on the screen</p><h2 id="11">Q3</h2><h2 id="12">a)</h2><p>The neutral signal from the monitor can be taken as [1 1 1]. To represent it as a vector, it is transposed. Then we compute the spectral signal reaching the eye by multiplying the primaries with the monitor intensities. The coneResponse is then computed by multiplying the cones matrix that hold the cone responsivity to the different wavelengths by the spectral signal reaching the eye for the neutral stimulus</p><pre class="codeinput">spectral_signal_neutral_stimulus = phosphors' * [1 1 1]';
coneResponse_neutral_stimulus = cones * spectral_signal_neutral_stimulus;
disp(<span class="string">'The cone responses to the neutral stimulus are:'</span>)
disp(coneResponse_neutral_stimulus)
</pre><pre class="codeoutput">The cone responses to the neutral stimulus are:
    0.2638
    0.2257
    0.1591

</pre><h2 id="13">b)</h2><p>The incremenet here is taken to be [0 0 1] to bring about an increment only in the S cone response The coresponding monitor singals can be computed by multiplying the cones_to_phosphors with the coneRespones with increment</p><pre class="codeinput">increment = [0 0 1]';
coneResponse_neutral_with_increment = coneResponse_neutral_stimulus + increment;
monitorSignals_with_increment = cones_to_phosphors * coneResponse_neutral_with_increment;
disp(<span class="string">'Monitor signals corresponding to the increment of [0 0 1] in cone responses are:'</span>)
disp(monitorSignals_with_increment)
</pre><pre class="codeoutput">Monitor signals corresponding to the increment of [0 0 1] in cone responses are:
    1.9637
   -0.3891
    8.3776

</pre><p>The negative monitor intensities cannot be rendered properly on the screen, thus bringing a constraint on the increment in the cone intensities that can be added. The maximum increment that can be added can be computed either by Brute-force method or by using Matrix multiplication method</p><h2 id="15">i) Brute-force method</h2><pre class="codeinput">iterations = 100;
format <span class="string">long</span>
brute_incre = [0 0.5];
<span class="keyword">for</span> i = 1:iterations
    coneResponse_with_increment_brute = coneResponse_neutral_stimulus + [0 0 1]' .* brute_incre(end);
    monitorSignals_with_increment_brute = cones_to_phosphors * coneResponse_with_increment_brute;
    delta = abs((brute_incre(end) - brute_incre(end - 1)) / 2);
    <span class="keyword">if</span> monitorSignals_with_increment_brute(2) &lt; 0
        change = brute_incre(end) - delta;
    <span class="keyword">else</span>
        change = brute_incre(end) + delta;
    <span class="keyword">end</span>
    brute_incre(end + 1) = change;
<span class="keyword">end</span>
max_brute_incre = brute_incre(end);
disp(<span class="string">'The maximum increment to S-cone computed by brute-force method is:'</span>)
disp(max_brute_incre);
</pre><pre class="codeoutput">The maximum increment to S-cone computed by brute-force method is:
   0.719882591314830

</pre><h2 id="16">ii) Matrix-multiplication method</h2><p>The monitor signal (mon_sig) is the product of cones_to_phosphors (C2P) matrix and the cone signal (con_sig). Hence we have:</p><p>mon_sig (old) = C2P * con_sig (old)</p><p>and</p><p>mon_sig (new) = C2P * con_sig (new)</p><p>But con_sig (new) = con_sig (old) + increment</p><p>Thus, we have:</p><p>mon_sig (new) = C2P * [con_sig (old) + increment]</p><p>Therefore,</p><p>mon_sig (new) = C2P * con_sig (old) + C2P * increment</p><p>Therefore,</p><p>mon_sig (new) = mon_sig (old) + C2P * increment</p><p>Since mon_sig (old) = [1 1 1]'</p><p>mon_sig (new) = [1 1 1]' + C2P * increment</p><p>From the monitor signals computed above, the limiting signal that can cause issue with the rendering is the middle signal. Therefore, the maximum increment that can be made to the cone response is the one that will result in mon_sig (new) (2) = 0</p><p>Now using the definitions of matrix multiplication, we have:</p><p>mon_sig (new) (2) = 1 + C2P(2, 1) * increment(1) + C2P(2, 2) * increment(2) + C2P(2, 3) * increment(3) = 0</p><p>Since the increment is only made to the S cone, we have</p><p>increment = [0 0 x]'</p><p>Thus, we have;</p><p>0 = 1 + C2P(2, 3) * increment(3)</p><p>Therefore, -1 = C2P(2, 3) * increment(3)</p><p>Therefore, increment(3) = -1/C2P(2, 3)</p><p>Using this, we get:</p><pre class="codeinput">format <span class="string">short</span>
max_incre_proper = -1/cones_to_phosphors(2, 3);
disp(<span class="string">'The maximum increment to S-cone computed by matrix-multiplication method is:'</span>)
disp(max_incre_proper);
</pre><pre class="codeoutput">The maximum increment to S-cone computed by matrix-multiplication method is:
    0.7199

</pre><h2 id="39">c)</h2><p>The conesignals after largest increment are: The coresponding monitor singals can be computed by multiplying the cones_to_phosphors with the coneRespones with the maximum increment</p><pre class="codeinput">coneResponse_neutral_with_max_increment = coneResponse_neutral_stimulus + [0 0 max_incre_proper]';
monitorSignals_with_max_increment = cones_to_phosphors * coneResponse_neutral_with_max_increment;
disp(<span class="string">'Monitor signals corresponding to the maximum increment in cone responses are:'</span>)
disp(monitorSignals_with_max_increment)
</pre><pre class="codeoutput">Monitor signals corresponding to the maximum increment in cone responses are:
    1.6938
    0.0000
    6.3110

</pre><h2 id="40">Q4</h2><p>First step is create a matrix of primaries. P_CIE is initialized to be a 31 * 3 matrix of zeroes where the columns correspond to the intensities of primaries 1, 2, 3 respectively. In this case, primary 1 = 700 nm, primary 2 = 550 nm, primary 3 = 440 nm.</p><pre class="codeinput">P_CIE = zeros(31, 3);
desired_monochromatics = [700, 550, 440];
</pre><p>Next step is to update the values of the intensities for each primary. This can be done by searching the index of the particular wavelength in the spectrum vector and assigning 1 in the corresponding row for each column in the P_new.</p><pre class="codeinput"><span class="keyword">for</span> i = 1:size(P_CIE, 2)
    lambda = desired_monochromatics(i);
    P_new_row_index = find(spectrum == lambda);
    P_CIE(P_new_row_index, i) = 1;
<span class="keyword">end</span>
</pre><p>The intensity of 700 nm is updated to be 80 times the intensity of other two primaries for scaling the graph</p><pre class="codeinput">P_CIE(:, 1) = 80 * P_CIE(:, 1);
</pre><p>A range of test lights can be created one for each wavelength in the range being sampled which can be modeled as an identity square matrix of size 31, with each column corresponding to one test light</p><pre class="codeinput">test_light_array = eye(31);
</pre><p>The color matching function can then be computed using CMF = inv(CP)*C*T This will create a matrix of size 3 * 31 with each column corresponding to the knob settings for that particular wavelength.</p><pre class="codeinput">CMF_CIE = inv(cones * P_CIE) * cones * test_light_array;
</pre><p>The plot of CMF is then created with the primaries colored as red, green, blue, respectively</p><pre class="codeinput">h = plot(spectrum, CMF_CIE, <span class="string">'LineWidth'</span>, 2);
set(h, {<span class="string">'color'</span>}, {[1 0 0 ]; [0 1 0]; [0 0 1]})
xlabel(<span class="string">'${\lambda}$ (nm)'</span>, <span class="string">'interpreter'</span>, <span class="string">'latex'</span>)
ylabel(<span class="string">'Intensity (AU)'</span>)
title(<span class="string">'CIE color matching functions'</span>)
legend(<span class="string">'700 nm'</span>, <span class="string">'550 nm'</span>, <span class="string">'440 nm'</span>)
</pre><img vspace="5" hspace="5" src="color_assignment_03.png" alt=""> <h2 id="46">Q5</h2><h2 id="47">a)</h2><p>Let C = cones, P_{old} = P_CIE, P_{new} = phosphors', e_{old} = CMF_CIE, e_{new} = CMF_new</p><p>The old color matching equation is:</p><p>Ct = CP_{old}e_{old}</p><p>And the new color matching equation is:</p><p>Ct = CP_{new}e_{new}</p><p>Since the perception of both the old primaries with the old settings and the new primaries with the new stting is the same, we can equate the right-hand side of the two equations</p><p>Hence, CP_{old}e_{old} = CP_{new}e_{new}</p><p>Given the invertibility of CP_{new}, we can create a new matrix old_to_new as</p><p>old_to_new = inv(CP_{new}) * (CP_{old})</p><p>Therefore, e_{new} = old_to_new * e_{old}</p><h2 id="57">b)</h2><p>The 3 * 3 matrix that is desired here is the old_to_new stated in (a). Substituting the matrices in the equation for old_to_new, we get:</p><pre class="codeinput">P_old = P_CIE;
P_new = phosphors';
old_to_new = inv(cones * P_new) * (cones * P_old);
disp(<span class="string">'The 3x3 matrix that converts the CIE color matching functions to the new color matching functions is:'</span>)
disp(old_to_new)
</pre><pre class="codeoutput">The 3x3 matrix that converts the CIE color matching functions to the new color matching functions is:
    8.8624    0.0655    0.6738
   -1.9196    6.1927   -1.0220
   -0.0999   -0.6997    7.3453

</pre><p>The old_to_new matrix is a transformation matrix that provides weights for the conversion from the old scale to the new scale. Let W = old_to_new. Then Wij is the weight of the i_th new primary with respect to the j_th old primary</p><h2 id="59">c)</h2><p>The new CMF can then be computed by multiplying the old_to_new matrix and the old CMF.</p><pre class="codeinput">CMF_new = old_to_new * CMF_CIE;
h = plot(spectrum, CMF_new, <span class="string">'LineWidth'</span>, 2);
set(h, {<span class="string">'color'</span>}, {[1 0 0 ]; [0 1 0]; [0 0 1]})
xlabel(<span class="string">'${\lambda}$ (nm)'</span>, <span class="string">'interpreter'</span>, <span class="string">'latex'</span>)
ylabel(<span class="string">'Intensity (AU)'</span>)
title(<span class="string">'New color matching functions'</span>)
legend(<span class="string">'P_L'</span>, <span class="string">'P_M'</span>, <span class="string">'P_S'</span>)
</pre><img vspace="5" hspace="5" src="color_assignment_04.png" alt=""> <p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2020b</a><br></p></div><!--
##### SOURCE BEGIN #####
clear; clc; close all;

% Loading all the datasets
load surfaces;
load illuminants;
load cones;
load phosphors;

%% Q1
% First a linear vector is created using linspace to list a range of
% wavelengths between 400 and 700 nm to map the visual spectrum. A standard
% size of 31 spacings is used which ensures a 10 nm step size.
spectrum = linspace(400, 700, 31);

%% a)
% The SPD of illuminant A is given by cie_a which is 1 * 31 and the 18th macbeth surface
% reflectance is stored in the 18th row of macbeth matrix which has a shape
% of 1 * 31. Therefore, value-by-value multiplication of macbeth 18th row 
% and cie_a is performed to compute the spectral signal reaching the eye. 
% To ensure that the resulting spectral signal is a column vector, both the 
% macbeth 18th row and the cia_a are transposed before computing the product
spectral_signal_18_ciea = macbeth(18, :)' .* cie_a';
figure;
plot(spectrum,spectral_signal_18_ciea,'r', 'LineWidth', 2);
xlabel('Wavelength (nm)');
ylabel('Reflected Energy');
title('Reflected energy off 18th surface illuminated by illuminant A')

%% b)
% Similar to (a), the 18th macbeth surface vector is multiplied by the SPD
% of the fluorescent light to compute the spectral signal reaching the eye
spectral_signal_18_fluroescent = macbeth(18, :)' .* flourescent';
figure;
plot(spectrum,spectral_signal_18_fluroescent,'g', 'LineWidth', 2);
xlabel('Wavelength (nm)');
ylabel('Reflected Energy');
title('Reflected energy off 18th surface illuminated by fluorescent illuminant')

%% c)
% The cone responses are the product of the matrix comprised of cone
% responsitivities as a function of wavelength and the spectral signal
% present in the incident light on the retina computed in (a) for
% illuminant A. The cones matrix is 3 * 31 and spectral_signal is 31 * 1
% resulting in the coneResponse vector shaped 3 * 1 with values
% corresponding to the responses by [L M S] cones.
coneResponse_18th_ciea = cones * spectral_signal_18_ciea;
disp('The cone responses for illuminant A reflecting off 18th Macbeth surface are:')
disp(coneResponse_18th_ciea);

%% d)
% Similar to what is done in (c), the cones matrix here is multiplied by
% the spectral signal for the fluorescent light from (b) and the result is a
% 3 * 1 coneResponse vector for the fluorescent light
coneResponse_18th_fluorescent = cones * spectral_signal_18_fluroescent;
disp('The cone responses for fluroescnet light reflecting off 18th Macbeth surface are:')
disp(coneResponse_18th_fluorescent);

%% e)
% The fluorescent light will appear more blueish as the cone response of S
% cone is higher in case of fluorescent light compared to that for the
% illuminant A. S cone responds to shorter wavelengths which are
% interpreted as blueish by the brain.

%% Q2
%% a)
% This is a color matching experiment where illuminant A acts as the test
% light and the monitor intensities are the knob settings of the three primaries.
% First the spectral signal reaching the eye when illuminant A is shined on 
% the 1st Macbeth surface is computed in a similar way as in Q1 a, b.
% Next the coneResponse is computed as the matrix product of the cones and
% the spectralSignal similar as in Q1 c, d.
% Then a matrix is computed to convert the signals from phosphors to the
% signals from cones as a product of cones and phosphors. Since both cones 
% and phosphors are 3 * 31, phosphors is transposed. The result is a 3 * 3
% matrix.
% Given the linear independence of the three primaries i.e. phosphors and
% the responsivities of the three cones, the resultant phosphors_to_cones
% matrix is invertible and the inverse of this matrix gives
% cones_to_phosphors, a 3 * 3 matrix, that can be used to convert the
% signals from cones to the corresponding light intensities from the
% monitor.
% The monitorSignals can then be computed as the product of
% cones_to_phosphors and coneResponse
spectral_signal_1_ciea = macbeth(1, :)' .* cie_a';
coneResponse_1st_ciea = cones * spectral_signal_1_ciea;
phosphors_to_cones = cones * phosphors';
cones_to_phosphors = inv(phosphors_to_cones);
monitorSignals = cones_to_phosphors * coneResponse_1st_ciea;
disp('The monitor intensities to match the color of the 1st Macbeth surface when illuminated by illuminant A are:')
disp(monitorSignals)

%% b)
% Since all the intensities are greater than 0 and assuming that there is
% no maximum intensity limit for the light produced by the monitor, this
% color can be displayed on the screen

%% Q3
%% a)
% The neutral signal from the monitor can be taken as [1 1 1]. To represent
% it as a vector, it is transposed. Then we compute the spectral
% signal reaching the eye by multiplying the primaries with the monitor
% intensities.
% The coneResponse is then computed by multiplying the cones matrix that
% hold the cone responsivity to the different wavelengths by the spectral
% signal reaching the eye for the neutral stimulus
spectral_signal_neutral_stimulus = phosphors' * [1 1 1]';
coneResponse_neutral_stimulus = cones * spectral_signal_neutral_stimulus;
disp('The cone responses to the neutral stimulus are:')
disp(coneResponse_neutral_stimulus)

%% b)
% The incremenet here is taken to be [0 0 1] to bring about an increment
% only in the S cone response
% The coresponding monitor singals can be computed by multiplying the
% cones_to_phosphors with the coneRespones with increment
increment = [0 0 1]';
coneResponse_neutral_with_increment = coneResponse_neutral_stimulus + increment;
monitorSignals_with_increment = cones_to_phosphors * coneResponse_neutral_with_increment;
disp('Monitor signals corresponding to the increment of [0 0 1] in cone responses are:')
disp(monitorSignals_with_increment)

%%
% The negative monitor intensities cannot be rendered properly on the
% screen, thus bringing a constraint on the increment in the cone
% intensities that can be added. The maximum increment that can be added
% can be computed either by Brute-force method or by using Matrix
% multiplication method
%% i) Brute-force method
iterations = 100;
format long
brute_incre = [0 0.5];
for i = 1:iterations
    coneResponse_with_increment_brute = coneResponse_neutral_stimulus + [0 0 1]' .* brute_incre(end);
    monitorSignals_with_increment_brute = cones_to_phosphors * coneResponse_with_increment_brute;
    delta = abs((brute_incre(end) - brute_incre(end - 1)) / 2);
    if monitorSignals_with_increment_brute(2) < 0
        change = brute_incre(end) - delta;       
    else
        change = brute_incre(end) + delta;
    end
    brute_incre(end + 1) = change;      
end
max_brute_incre = brute_incre(end);
disp('The maximum increment to S-cone computed by brute-force method is:')
disp(max_brute_incre);

%% ii) Matrix-multiplication method
% The monitor signal (mon_sig) is the product of cones_to_phosphors (C2P) matrix and the
% cone signal (con_sig).
% Hence we have:
%%
% mon_sig (old) = C2P * con_sig (old)
%%
% and
%%
% mon_sig (new) = C2P * con_sig (new)
%%
% But con_sig (new) = con_sig (old) + increment
%%
% Thus, we have:
%%
% mon_sig (new) = C2P * [con_sig (old) + increment]
%%
% Therefore,
%%
% mon_sig (new) = C2P * con_sig (old) + C2P * increment
%%
% Therefore,
%%
% mon_sig (new) = mon_sig (old) + C2P * increment
%%
% Since mon_sig (old) = [1 1 1]'
%%
% mon_sig (new) = [1 1 1]' + C2P * increment
%%
% From the monitor signals computed above, the limiting signal that can
% cause issue with the rendering is the middle signal. Therefore, the
% maximum increment that can be made to the cone response is the one that
% will result in mon_sig (new) (2) = 0
%%
% Now using the definitions of matrix multiplication, we have:
%%
% mon_sig (new) (2) = 1 + C2P(2, 1) * increment(1) + C2P(2, 2) *
% increment(2) + C2P(2, 3) * increment(3) = 0
%%
% Since the increment is only made to the S cone, we have 
%%
% increment = [0 0 x]'
%%
% Thus, we have;
%%
% 0 = 1 + C2P(2, 3) * increment(3)
%%
% Therefore, -1 = C2P(2, 3) * increment(3)
%%
% Therefore, increment(3) = -1/C2P(2, 3)
%%
% Using this, we get:
format short
max_incre_proper = -1/cones_to_phosphors(2, 3);
disp('The maximum increment to S-cone computed by matrix-multiplication method is:')
disp(max_incre_proper);

%% c)
% The conesignals after largest increment are:
% The coresponding monitor singals can be computed by multiplying the
% cones_to_phosphors with the coneRespones with the maximum increment
coneResponse_neutral_with_max_increment = coneResponse_neutral_stimulus + [0 0 max_incre_proper]';
monitorSignals_with_max_increment = cones_to_phosphors * coneResponse_neutral_with_max_increment;
disp('Monitor signals corresponding to the maximum increment in cone responses are:')
disp(monitorSignals_with_max_increment)

%% Q4
% First step is create a matrix of primaries. P_CIE is initialized to be a
% 31 * 3 matrix of zeroes where the columns correspond to the intensities
% of primaries 1, 2, 3 respectively. In this case, primary 1 = 700 nm,
% primary 2 = 550 nm, primary 3 = 440 nm.
P_CIE = zeros(31, 3);
desired_monochromatics = [700, 550, 440];

%%
% Next step is to update the values of the intensities for each primary.
% This can be done by searching the index of the particular wavelength in
% the spectrum vector and assigning 1 in the corresponding row for each
% column in the P_new.
for i = 1:size(P_CIE, 2)
    lambda = desired_monochromatics(i);
    P_new_row_index = find(spectrum == lambda);
    P_CIE(P_new_row_index, i) = 1;
end  

%%
% The intensity of 700 nm is updated to be 80 times the intensity of other
% two primaries for scaling the graph
P_CIE(:, 1) = 80 * P_CIE(:, 1);

%%
% A range of test lights can be created one for each wavelength in the
% range being sampled which can be modeled as an identity square matrix of
% size 31, with each column corresponding to one test light
test_light_array = eye(31);

%%
% The color matching function can then be computed using 
% CMF = inv(CP)*C*T
% This will create a matrix of size 3 * 31 with each column corresponding
% to the knob settings for that particular wavelength.
CMF_CIE = inv(cones * P_CIE) * cones * test_light_array;

%%
% The plot of CMF is then created with the primaries colored as red, green, 
% blue, respectively
h = plot(spectrum, CMF_CIE, 'LineWidth', 2);
set(h, {'color'}, {[1 0 0 ]; [0 1 0]; [0 0 1]})
xlabel('${\lambda}$ (nm)', 'interpreter', 'latex')
ylabel('Intensity (AU)')
title('CIE color matching functions')
legend('700 nm', '550 nm', '440 nm')


%% Q5
%% a)
% Let C = cones, P_{old} = P_CIE, P_{new} = phosphors', e_{old} = CMF_CIE,
% e_{new} = CMF_new
%%
% The old color matching equation is:
%%
% Ct = CP_{old}e_{old}
%%
% And the new color matching equation is:
%%
% Ct = CP_{new}e_{new}
%%
% Since the perception of both the old primaries with the old settings and
% the new primaries with the new stting is the same, we can equate the
% right-hand side of the two equations
%%
% Hence, CP_{old}e_{old} = CP_{new}e_{new}
%%
% Given the invertibility of CP_{new}, we can create a new matrix
% old_to_new as
%%
% old_to_new = inv(CP_{new}) * (CP_{old})
%%
% Therefore, e_{new} = old_to_new * e_{old}

%% b)
% The 3 * 3 matrix that is desired here is the old_to_new stated in (a).
% Substituting the matrices in the equation for old_to_new, we get:
P_old = P_CIE;
P_new = phosphors';
old_to_new = inv(cones * P_new) * (cones * P_old);
disp('The 3x3 matrix that converts the CIE color matching functions to the new color matching functions is:')
disp(old_to_new)
%%
% The old_to_new matrix is a transformation matrix that provides weights
% for the conversion from the old scale to the new scale. Let W =
% old_to_new. Then Wij is the weight of the i_th new primary with respect
% to the j_th old primary

%% c)
% The new CMF can then be computed by multiplying the old_to_new matrix and
% the old CMF.
CMF_new = old_to_new * CMF_CIE;
h = plot(spectrum, CMF_new, 'LineWidth', 2);
set(h, {'color'}, {[1 0 0 ]; [0 1 0]; [0 0 1]})
xlabel('${\lambda}$ (nm)', 'interpreter', 'latex')
ylabel('Intensity (AU)')
title('New color matching functions')
legend('P_L', 'P_M', 'P_S')

##### SOURCE END #####
--></body></html>